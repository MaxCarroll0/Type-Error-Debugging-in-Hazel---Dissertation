\chapter{Slicing Theory}
\label{sec:SlicingTheory}
\section{Expression Typing Slices}
\subsection{Term Slices}
\subsubsection{Syntax}
Extending core Hazel syntax with patterns $pt = \_ \mid x$ where $\_$ is the wildcard pattern (binding the argument to nothing).

\begin{definition}[Term Slice Syntax]
\label{def:ExpressionSliceSyntaxAppendix}
Pattern expression slices $p$:
\[p ::= \gap_{\text{pat}} \mid \_ \mid x\]
Type slices $\upsilon$:
\[\upsilon ::= \gap_{\text{typ}} \mid \dyn \mid b \mid \upsilon \to \upsilon\]
Expression slices $\varsigma$:
\[\varsigma ::= \gap_{\text{exp}} \mid  c \mid x \mid \lambda p : \upsilon.\ \varsigma \mid \lambda p.\ \varsigma \mid \varsigma(\varsigma) \mid \hole^u \mid \hole[\varsigma]^u \mid \varsigma : \upsilon\]
\end{definition}
Note: labels for gaps are generally omitted, being determined from their position.
\subsubsection{Precision Relation}
\begin{definition}[Term Precision]
Pattern slices $p$:
\[\inference{}{\gap_{\text{pat}} \sqsubseteq p} \qquad \inference{}{x \sqsubseteq x}\]
Type slices $\upsilon$:
\[\inference{}{\gap_{\text{typ}} \sqsubseteq \upsilon} \qquad \inference{}{\upsilon \sqsubseteq \upsilon} \qquad \inference{\upsilon_1' \sqsubseteq \upsilon_1 & \upsilon_2' \sqsubseteq \upsilon_2}{\upsilon_1' \to \upsilon_2' \sqsubseteq \upsilon_1 \to \upsilon_2}\]
Expression slices $\varsigma$:
\[\inference{}{\gap_{\text{exp}} \sqsubseteq \varsigma} \qquad \inference{}{\varsigma \sqsubseteq \varsigma} \qquad \inference{p' \sqsubseteq p & \upsilon' \sqsubseteq \upsilon & \varsigma' \sqsubseteq \varsigma}{\lambda p' : \upsilon'.\ \varsigma' \sqsubseteq \lambda p : \upsilon.\ \varsigma}\]
\[\inference{p' \sqsubseteq p & \varsigma' \sqsubseteq \varsigma}{\lambda p'.\ \varsigma' \sqsubseteq \lambda p.\ \varsigma} \qquad \inference{\varsigma_1' \sqsubseteq \varsigma_1 & \varsigma_2' \sqsubseteq \varsigma_2}{\varsigma_1'(\varsigma_2') \sqsubseteq \varsigma_1(\varsigma_2)} \qquad \inference{\varsigma' \sqsubseteq \varsigma & \upsilon' \sqsubseteq \upsilon}{\varsigma' : \upsilon' \sqsubseteq \varsigma : \upsilon}\]
\end{definition}

\begin{proposition}[Precision is a Partial Order]
Term precision forms a partial order on term slices. That is:
\[\inference{}{\varsigma \sqsubseteq \varsigma} \quad \inference{\varsigma_1 \sqsubseteq \varsigma_2 & \varsigma_2 \sqsubseteq \varsigma_1}{\varsigma_1 = \varsigma_2} \quad \inference{\varsigma_1 \sqsubseteq \varsigma_2 & \varsigma_2 \sqsubseteq \varsigma_3}{\varsigma_1 \sqsubseteq \varsigma_3}\]
\end{proposition}
\begin{proof}
TODO typeset
\end{proof}

\subsubsection{Lattice Structure}
\begin{proposition}[Term Slice Bounded Lattice]
For any term $t$, the set of slices $\varsigma_1$ and $\varsigma_2$ of $t$ forms a bounded lattice:
\begin{itemize}
\item The join, $\varsigma_1 \sqcup \varsigma_2$ exists , being an upper bound for $\varsigma_1, \varsigma_2$:
\[\varsigma_1 \sqsubseteq \varsigma_1 \sqcup \varsigma_2\qquad \varsigma_2 \sqsubseteq \varsigma_1 \sqcup \varsigma_2\]
And, any other slice $\varsigma \sqsubseteq t$ which is also an upper bound of $\varsigma_1, \varsigma_2$ is more or equally precise than the join:
\[\varsigma_1 \sqcup \varsigma_2 \sqsubseteq \varsigma\]
\item The meet, $\varsigma_1 \sqcap \varsigma_2$ exists, being a lower bound for $\varsigma_1, \varsigma_2$:
\[\varsigma_1 \sqcap \varsigma_2 \sqsubseteq \varsigma_1\qquad  \varsigma_1 \sqcap \varsigma_2 \sqsubseteq\varsigma_2\]
And, any other slice $\varsigma \sqsubseteq t$ which is also a lower bound of $\varsigma_1, \varsigma_2$ is less or equally precise than the meet:
\[ \varsigma \sqsubseteq\varsigma_1 \sqcup \varsigma_2\]
\item And the join and meet operations satisfy the absorption laws for any slice $\varsigma$:
\[\varsigma_1 \sqcap (\varsigma_1 \sqcup \varsigma_2) = \varsigma_1 \qquad \varsigma_1 \sqcup (\varsigma_1 \sqcap \varsigma_2) = \varsigma_1\]
And idempotent laws:
\[\varsigma_1 \sqcup \varsigma_1 = \varsigma_1 = \varsigma_1 \sqcap \varsigma_1\]
\item The lattice is bounded. That is, $\gap \sqsubseteq \varsigma \sqsubseteq t$.
\end{itemize}
\end{proposition}
\begin{proof}
TODO typeset
\end{proof}


\subsection{Typing Assumption Slices}
\subsubsection{Typing Assumptions as Partial Functions}
\begin{definition}[Typing Assumptions]
A typing assumption function $\Gamma$ is a partial function from the set of variables $\mathcal{X}$ to types $\mathcal{T}$. A partial function is either defined $\Gamma(x) = \tau$ or undefined $\Gamma(x) = \bot$. It's domain $\mathrm{dom}(\Gamma)$ is largest the set of variables $S \subseteq \mathcal{X}$ for which $\Gamma$ is defined: $\forall x \in S.\ \Gamma(x) \neq \bot$.
\end{definition}

\subsubsection{Typing Assumption Slices}
\begin{definition}[Typing Assumption Slices]
A typing assumption slice $\gamma$ is a partial function from the set of variables $\mathcal{X}$ to type slices $\upsilon$.
\end{definition}
\subsubsection{Precision}
\begin{definition}[Typing Assumption Slice Precision]
For typing assumption slices $\gamma_1, \gamma_2$. Where $\mathrm{dom}(f)$ is the set of variables for which a partial function $f$ is \textit{defined}:
\[\gamma_1 \sqsubseteq \gamma_2 \iff \mathrm{dom}(\gamma_1) \subseteq \mathrm{dom}(\gamma_2) \text{ and } \forall x \in  \mathrm{dom}(\gamma_1).\ \gamma_1(x) \sqsubseteq \gamma_2(x)\]
\end{definition}
\begin{proposition}[Precision is a Partial Order]
Typing assumption precision forms a partial order on typing assumption slices.
\end{proposition}
\begin{proof}
\textbf{Typeseting TODO}
\end{proof}
\subsubsection{Lattice Structure}
\begin{definition}[Typing Assumption Slice Joins and Meets]
For typing slices $\gamma_1, \gamma_2$, and any variable $x$:
\begin{itemize}
\item If $\gamma_1(x) = \bot$ then $(\gamma_1 \sqcup \gamma_2)(x) = \gamma_2(x)$ and $(\gamma_1 \sqcap \gamma_2)(x) = \bot$. 
\item If $\gamma_2(x) = \bot$ then $(\gamma_1 \sqcup \gamma_2)(x) = \gamma_1(x)$ and $(\gamma_1 \sqcap \gamma_2)(x) = \bot$
\item Otherwise, $(\gamma_1 \sqcup \gamma_2)(x) = \gamma_1(x) \sqcup \gamma_2(x)$.
\end{itemize}
\end{definition}

\begin{proposition}[Typing Assumption Slices form Bounded Lattices]
For any typing assumptions $\Gamma$, the set of slices $\gamma$ of $\Gamma$ form a bounded lattice with bottom element of the empty function $\emptyset$ and top element $\Gamma$.
\end{proposition}
\begin{proof}
Typsetting TODO
\end{proof}
\subsection{Expression Typing Slices}
\begin{definition}[Expression Typing Slices]
An expression typing slice $\rho$ is a pair $\varsigma^\gamma$ of expression slice $\varsigma$ and typing assumption slice $\gamma$.
\end{definition}

\subsubsection{Precision}
\begin{definition}[Expression Typing Slice Precision]
For expression typing slices $\varsigma_1^{\gamma_1}$, $\varsigma_2^{\gamma_2}$:
\[\varsigma_1^{\gamma_1} \sqsubseteq \varsigma_2^{\gamma_2} \iff  \varsigma_1 \sqsubseteq \varsigma_2 \text{ and } \gamma_1 \sqsubseteq \gamma_2\]
\end{definition}
\begin{proposition}[Precision is a Partial Order]
Expression typing precision forms a partial order on expression typing slices.
\end{proposition}
\begin{proof}
\textbf{Typesetting TODO}
\end{proof}
\subsubsection{Lattice Structure}

\begin{definition}[Expression Typing Slice Joins and Meets]
For expression typing slices $\varsigma_1^{\gamma_1}$, $\varsigma_2^{\gamma_2}$:
\[\varsigma_1^{\gamma_1} \sqcup \varsigma_2^{\gamma_2} = (\varsigma_1 \sqcup \varsigma_2)^{\gamma_1 \sqcup \gamma_2}\]
\[\varsigma_1^{\gamma_1} \sqcap \varsigma_2^{\gamma_2} = (\varsigma_1 \sqcap \varsigma_2)^{\gamma_1 \sqcap \gamma_2}\]
\end{definition}

\begin{proposition}[Expression Typing Slices for Bounded Lattices]
For any expression $e$ and typing assumption $\Gamma$, the set of expression typing slices $\varsigma^{\gamma}$ of $e^{\Gamma}$ forms a bounded lattice with bottom element $\gap^{\emptyset}$ and top element $e^{\Gamma}$.
\end{proposition}

\subsubsection{Type Checking}
\begin{definition}[Interpreting Term Slices as Terms]
By replacing gaps in terms with holes, the dynamic type, or wildcard patterns, slices can be interpreted as terms. For gaps:
\[\inference{}{\type{\gap_{\text{typ}}} = \dyn} \qquad \inference{}{\type{\gap_{\text{pat}}} = \_} \qquad \inference{u\text{ is fresh}}{\type{\gap_{\text{exp}}} = \hole^u}\]
Patterns:
\[\inference{}{\type{\_} = \_} \qquad \inference{}{\type{x} = x}\]
Types:
\[\inference{}{\type{\tau} = \tau} \qquad \inference{\type{\upsilon_1} = \tau_1 & \type{\upsilon_2} = \tau_2}{\type{\upsilon_1 \to \upsilon_2} = \tau_1 \to \tau_2}\]
Expressions:
\[\inference{}{\type{e} = e} \qquad \inference{\type{p} = pt & \type{\upsilon} = \tau & \type{\varsigma} = e}{\type{\lambda p : \upsilon.\ \varsigma} = \lambda pt : \tau.\ e} \qquad \inference{\type{p} = pt & \type{\varsigma} = e}{\type{\lambda p.\ \varsigma} = \lambda pt.\ e}\]
\[\inference{\type{\varsigma_1} = e_1 & \type{\varsigma_2} = e_2}{\type{\varsigma_1(\varsigma_2)} = e_1(e_2)} \qquad \inference{\type{\varsigma} = e & \type{\upsilon} = \tau}{\type{\varsigma : \upsilon} = e : \tau}\]
\end{definition}
\begin{definition}[Interpreting Typing Assumption slices by Typing Assumptions]
Translated by extension, for typing assumption slice $\gamma$:
\[\type{\gamma}(x) = \type{\gamma(x)} \qquad \text{if $\gamma(x) \neq \bot$}\]
\[\type{\gamma}(x) = \bot \qquad \text{if $\gamma(x) = \bot$}\]
\end{definition}

\begin{definition}[Expression Typing Slice Type Checking]
For expression typing slice $\varsigma^{\gamma}$ and type $\tau$. $\synthesis[\gamma]{\varsigma}{\tau}$ iff $\synthesis[\type{\gamma}]{\type{\varsigma}}{\tau}$ and $\analysis[\gamma]{\varsigma}{\tau}$ iff $\analysis[\type{\gamma}]{\type{\varsigma}}{\tau}$.
\end{definition}

\section{Context Typing Slices}
\subsection{Contexts}
\begin{definition}[Contexts Syntax]
Pattern contexts -- mapping patterns to patterns:
\[\mathdcal{P} ::= \cmark_{\text{pat}}\]
Type contexts -- mapping types to types: 
\[\mathdcal{T} ::= \cmark_{\text{typ}} \mid \mathdcal{T} \to \tau \mid \tau \to \mathdcal{T}\]
Expression contexts -- mapping patterns, types, or expression to expressions:\footnote{Note that $\C$ is also used for generic term contexts sometimes.}
\[\C ::=  \cmark_{\text{exp}} \mid \lambda \mathdcal{P} : \tau.\ e \mid \lambda pt : \mathdcal{T}.\ e \mid \lambda pt : \tau.\ \C \mid \lambda \mathdcal{P}.\ e \mid \lambda pt.\ \C \mid \C(e) \mid e(\C) \mid e : \mathdcal{T} \mid \C : \tau\]
\end{definition}
\begin{definition}[Context Substitution]
\[\inference{}{\cmark_{\text{pat}}\{pt\} = pt} \qquad \inference{}{\cmark_{\text{typ}}\{\tau\} = \tau} \inference{}{\cmark_{\text{exp}}\{e\} = e}\]
\[\inference{\mathdcal{T}\{\tau_1\} = \tau_1'}{(\mathdcal{T} \to \tau_2)\{\tau_1\} = \tau_1' \to \tau_2} \qquad \inference{\mathdcal{T}\{\tau_2\} = \tau_2'}{(\tau_1 \to \mathdcal{T})\{\tau_2\} = \tau_1 \to \tau_2'}\]
\[\inference{\mathdcal{P}\{pt\} = pt'}{(\lambda \mathdcal{P} : \tau.\ e)\{pt\} = \lambda pt' : \tau.\ e} \qquad \inference{\mathdcal{P}\{pt\} = pt'}{(\lambda \mathdcal{P}.\ e)\{pt\} = \lambda pt'.\ e}\]
\[\inference{\mathdcal{T}\{\tau\} = \tau'}{(\lambda pt : \mathdcal{T}.\ e)\{\tau\} = \lambda pt : \tau'.\ e} \qquad \inference{\mathdcal{T}\{\tau\} = \tau'}{(e : \mathdcal{T})\{\tau\} = e : \tau'}\]
\[\inference{\C\{e\} = e'}{(\lambda pt : \tau.\ \C)\{\tau\} = \lambda pt : \tau.\ e'} \qquad \inference{\C\{e\} = e'}{(\lambda pt.\ \C)\{\tau\} = \lambda pt.\ e'} \qquad \inference{\C\{e_1\} = e_1'}{(\C(e_2))\{e_1\} = e_1'(e_2)}\]
\[\inference{\C\{e_2\} = e_2'}{(e_1(\C))\{e_2\} = e_1(e_2')} \qquad \inference{\C\{e\} = e'}{(\C : \tau)\{e\} = e' : \tau}\]
The input and output classes of contexts $\C$ will be notated $\C : \code{X} \to \code{Y}$ for $\code{Pat}$ (patterns), \code{Typ} (types), \code{Exp} (expressions).
\end{definition}
\begin{definition}[Context Composition]
Defined analogously as context substitution, but substituting contexts syntactically, provided the input and output classes match. If $\C_1 : \code{X} \to \code{Y}$ and $\C_2 : \code{Y} \to \code{Z}$ then $\C_2\{C_1\} = \C_2 \circ \C_1 : \code{X} \to \code{Z}$. Equivalence of contexts can be defined syntactically and coincides exactly with an extensional definition.
\end{definition}
\begin{proposition}[Context composition is associative]
For all $\C_1 : \code{X} \to \code{Y}$, $\C_2 : \code{Y} \to \code{Z}$, and $\C_3 : \code{Z} \to \code{W}$ then:
\[(\C_3 \circ \C_2) \circ C_1 = \C_3 \circ (\C_2 \circ C_1)\]
\end{proposition}
\begin{proof}
\textbf{Typesetting todo.}
\end{proof}

\subsection{Context Slices}
Syntax extended analogously to term slices. Use $\Cs$ to represent context slices.

\subsubsection{Precision}
\begin{definition}[Context Precision]\label{def:ContextPrecisionAppendix}
If $\Cs : \code{X} \to \code{Y}$ and $\Cs' : \code{X} \to \code{Y}$ are context slices, then $\Cs' \sqsubseteq \Cs$ if and only if, for all terms $t$ of class $\code{X}$, that $\Cs'\{t\} \sqsubseteq \Cs\{t\}$.
\end{definition}
\begin{proposition}[Precision is a Partial Order]
Context precision forms a partial order on context slices.
\end{proposition}
\begin{proof}
\textbf{Typesetting TODO}
\end{proof}
\begin{proposition}[Context Filling Preserves Precision]
For context slice $\Cs : \code{X} \to \code{Y}$ and term slice $\varsigma$ of class \code{X}. Then if we have slices $\varsigma' \sqsubseteq \varsigma$, $\Cs' \sqsubseteq \Cs$ then also $\Cs'\{\varsigma'\} \sqsubseteq \Cs\{\varsigma\}$.
\end{proposition}

\subsubsection{Lattice Structure}
\begin{definition}[Context Slice Joins \& Meets]
For context slices $\Cs_1 : \code{X} \to \code{Y}$ and $\Cs_2 : \code{X} \to \code{Y}$ and any term $t$ of class \code{X}:
\[(\Cs_1 \sqcup \Cs_2)\{t\} = \Cs_1\{t\} \sqcup \Cs_2\{t\}\]
\[(\Cs_1 \sqcap \Cs_2)\{t\} = \Cs_1\{t\} \sqcap \Cs_2\{t\}\]
\end{definition}
\begin{definition}[Purely Structural Contexts]
Least specific slices of some context, containing only gaps $\gap$ and the mark $\cmark$. The purely structural context of $\C$ is the unique one that is a slice of $\C$
\[\mathdcal{P}_s ::= \cmark_{\text{pat}}\]
\[\mathdcal{T}_s ::= \cmark_{\text{typ}} \mid \mathdcal{T}_s \to \gap \mid \gap \to \mathdcal{T}\]
\[\C_s ::=  \cmark_{\text{exp}} \mid \lambda \mathdcal{P} : \gap.\ \gap \mid \lambda \gap : \mathdcal{T}.\ \gap \mid \lambda \gap : \gap.\ \C \mid \lambda \mathdcal{P}.\ \gap \mid \lambda \gap.\ \C \mid \C(\gap) \mid \gap(\C) \mid \gap : \mathdcal{T} \mid \C : \gap\]
\end{definition}
\begin{proposition}[Context Slices form Bounded Lattices]
For any context $\C$, the set of slices $\Cs$ of $\C$ form a bounded lattice with bottom element of the \textit{purely structural context} of $\C$ and top element $\C$.
\end{proposition}
\begin{proof}
\textbf{Type Setting TODO}
\end{proof}
\subsection{Typing Assumption Contexts \& Context Slices}
\begin{definition}[Typing Assumption Contexts \& Slices]
A typing assumption context $\F$ is a function from typing assumption to typing assumptions. A typing assumption context slice $\f$ is a function from typing assumption slices to typing assumption slices.
\end{definition}
\subsubsection{Precision}
\begin{definition}[Typing Assumption Context Slice Precision]\label{def:FunctionPrecision}
If $\f'$ and $\f$ are typing assumption context slices, then $\f' \sqsubseteq \f$ if and only if, for all typing context slices $\gamma$, that $\f'(\gamma) \sqsubseteq \f(\gamma)$.
\end{definition}
\begin{proposition}[Precision is a Partial Order]
Typing assumption context precision forms a partial order on typing assumption context slices.
\end{proposition}
\begin{proof}
\textbf{Typesetting TODO}
\end{proof}
\begin{proposition}[Function Application Preserves Precision]
For typing assumption slice $\gamma$ and typing assumption context slice $\f$. Then if we have slices $\gamma' \sqsubseteq \gamma$, $f' \sqsubseteq f$ then also $f'(\gamma') \sqsubseteq f(\gamma)$.
\end{proposition}

\subsubsection{Lattice Structure}
\begin{definition}[Typing Assumption Context Slice Joins \& Meets] For typing assumption context slices $\f_1$ and $\f_2$ and any typing assumption slice $\gamma$:
\[(\f_1 \sqcup \f_2)(\gamma) = \f_1(\gamma) \sqcup \f_2(\gamma)\]
\[(\f_1 \sqcap \f_2)(\gamma) = \f_1(\gamma) \sqcap \f_2(\gamma)\]
\end{definition}

\begin{conjecture}[Typing Assumption Context Slices form Bounded Lattices]
For any typing assumption context $\F$, the set of slices $\f$ of $\F$ form a bounded lattice with bottom element being the constant function to the empty typing assumption function and top element $\F$.
\end{conjecture}

\subsection{Context Typing Slices}
\begin{definition}[Expression Context Typing Slice]
An expression context typing slice $\p$ is a pair $\Cs^\f$ of a context slice $\Cs$ and typing assumption context slice $\f$.
\end{definition}
\subsubsection{Precision}
\begin{definition}[Expression Context Typing Slice Precision]
For expression context typing slices $\Cs_1^{\f_1}$, $\Cs_2^{\f_2}$:
\[\Cs_1^{\f_1} \sqsubseteq \Cs_2^{\f_2} \iff  \Cs_1 \sqsubseteq \Cs_2 \text{ and } \f_1 \sqsubseteq \f_2\]
\end{definition}\begin{proposition}[Precision is a Partial Order]
Typing assumption context precision forms a partial order on typing assumption context slices.
\end{proposition}
\begin{proof}
Analogous to expression typing slices.
\end{proof}
\subsubsection{Composition}
\begin{definition}[Expression Context Typing Slice Composition \& Application]
For expression context typing slices $\Cs^{\f}$, $\Cs'^{\f'}$, and expression typing slices $\varsigma^{\gamma}$:
\[\Cs^{\f} \circ \Cs'^{\f'} =  (\Cs \circ \Cs')^{\f \circ \f'}\]
\[\Cs_1^{\f_1}\{\varsigma^{\gamma}\} =  \Cs_1\{\varsigma\}^{\f_1(\gamma)}\]
\end{definition}\begin{proposition}[Expression Context Slice Composition is Associative]
For all $\p_1$, $\p_2$, and $\p_3$ then:
\[(\p_3 \circ \p_2) \circ p_1 = \p_3 \circ (\p_2 \circ p_1)\]
\end{proposition}
\begin{proof}
\textbf{Typesetting TODO}
\end{proof}
\subsubsection{Lattice Structure}
\begin{definition}[Expression Context Typing Slice Joins and Meets]
For expression typing slices $\Cs_1^{\f_1}$, $\Cs_2^{\f_2}$:
\[\Cs_1^{\f_1} \sqcup \Cs_2^{\f_2} = (\Cs_1 \sqcup \Cs_2)^{\f_1 \sqcup \f_2}\]
\[\Cs_1^{\f_1} \sqcap \Cs_2^{\f_2} = (\Cs_1 \sqcap \Cs_2)^{\f_1 \sqcap \f_2}\]
\end{definition}

\begin{proposition}[Expression Context Typing Slices form Bounded Lattices]
For any expression context $\C$ and typing assumption context $\F$, the set of expression context typing slices $\Cs^{\f}$ of $\C^{\F}$ forms a bounded lattice with bottom element, the purely structural context and the function to the empty typing assumptions, and top element $e^{\Gamma}$.
\end{proposition}
\begin{proof}
\textbf{typsetting TODO}
\end{proof}
\subsubsection{Interpreting Context Typing Slices by Contexts and Typing Assumption Contexts}
A $\type{\Cs}$ function can be analogously defined as to expressions, replacing the gaps by $\_, \dyn,\hole^u$.

\section{Type-Indexed Slices}
\subsection{Type-Indexed Context Typing Slices}
\begin{definition}[Type-Indexed Context Typing Slices]
Syntactically defined: 
\[\S ::= \p \mid \p * \S \to \p * \S\] 
With any $\S$ only being valid if it has a full slice. The full slice of $\S$ is notated $\overline{\S}$ and defined recursively:
\[\overline{\p} = \p\]
\[\overline{\p_1 * \S_1 \to \p_2 * \S_2} = \p_1 \circ \overline{\S_1} \sqcup \p_2 \circ \overline{S_2}\]
\end{definition}
\begin{definition}[Type-Indexed Context Typing Slice Composition]
For type-indexed context typing slices $\S$ and $\S'$.  If $\S = \p$ and $\S' = \p'$:
\[\p' \circ \p = \overline{\p'} \circ \overline{\p}\qquad \p \circ \p' = \overline{\p} \circ \overline{\p'}\]
If $\S = \p$ and $\S' = \p_1' * \S_1' \to \p_2' * \S_2'$:
\[S \circ \S' = (\p \circ p_1') * \S_1' \to (\p \circ \p_2') * \S_2'\]
If $\S = \p_1 * \S_1 \to \p_2 * \S_2$:
\[\S \circ \S' = \p_1 * (\S_1 \circ \S') \to \p_2 * (\S_2 \circ \S')\]
\end{definition}

\begin{proposition}[Type-Indexed Composition Preserves Full Slice Composition]
For type-indexed slices $\S$ and $\S'$: 
\[\overline{\S \circ \S'} = \overline{\S} \circ \overline{\S'}\]
\end{proposition}
\begin{proof}
\textbf{typsetting todo}
\end{proof}
\subsection{Type-Indexed Expression Typing Slices}
(Overloading the $\S$ notation)
\begin{definition}[Type-Indexed Expressions Typing Slices]
Syntactically defined: 
\[\S ::= \rho \mid \p * \S \to \p * \S\] 
With any $\S$ only being valid if it has a full slice. The full slice of $\S$ is notated $\overline{\S}$ and defined recursively:
\[\overline{\rho} = \rho\]
\[\overline{\p_1 * \S_1 \to \p_2 * \S_2} = \p_1 \{ \overline{\S_1}\} \sqcup \p_2 \{ \overline{S_2}\}\]
\end{definition}
We retain left incremental composition/application as before (but applying to leaves $\rho$) but do not retain global right composition.
 
\subsection{Global Application}
Global application and reverse application can be defined to allow converting between context and expression slices.
\begin{definition}[Reverse Application]
For an expressions slice $\rho$. Reverse application $\mid>$ converts type-indexed context typing slices to type-indexed expressions typing slices:
\[\rho\ \mid>\ \p = \p(\rho)\]
\[\rho\mid>\ (\p_1 * \S_1 \to \p_2 * \S_2) = \p_1 * (\rho \mid>\ \S_1) \to \p_2 * (\rho\mid>\ \S_2)\]
\end{definition}
\begin{proposition}[Validity]
If $\S$ is a valid type indexed context typing slice. For all expression typing slices $\rho$, then $\rho \mid>\ \S$ is a valid type-indexed expression typing slice with the same structure as $\S$.
\end{proposition}
\begin{proof}
\textbf{typsetting TODO}
\end{proof}
\label{def:Application}
\begin{definition}[Application]
For a function $f$ from expression typing slices $\rho$ to context typing slices. Application $\$$ converts type-indexed expression typing slices to type-indexed context typing slices:
\[f\ \$\ \rho = f(\rho)\]
\[f\ \$\ (\p_1 * \S_1 \to \p_2 * \S_2) = \cmark * (f\ \$\ \p_1 \circ \S_1) \to \cmark * (f\ \$\ \p_2 \circ \S_2)\]
The contexts $\p_1, \p_2$ are eagerly applied down to the leaves $\rho$, to ensure the validity property.
\end{definition}
\begin{proposition}[Validity]
If $\S$ is a valid type indexed expression typing slice. For all functions $f$ from expression slices to context slices, then $f\ \$\ \S$ is a valid type-indexed context typing slice with the same structure as $\S$.
\end{proposition}
\begin{proof}
\textbf{typsetting TODO}
\end{proof}

\section{Checking Contexts}
\label{sec:CheckingContexts}
\begin{definition}[Checking Context]
\label{def:CheckingContextAppendix}
For term $e$ checking against $\tau$: $\analysis[\Gamma]{e}{\tau}$. A checking context for $e$ is an expression context $\C$ and typing assumption context $\F$ such that: 
\begin{itemize}
\item $\C \neq \cmark$.
\item $\synthesis[\F(\Gamma)]{\C\{e\}}{\tau'}$ for some $\tau'$.
\item The above derivation has a sub-derivation $\analysis[\Gamma]{e}{\tau}$.
\end{itemize}
\end{definition}
\begin{definition}[Minimally Scoped Checking Context]
For a derivation $\analysis[\Gamma]{e}{\tau}$, a minimally scoped expression checking context is a checking context of $e$ such that no sub-context is also a checking context.
\end{definition}

\begin{proposition}[Minimally Scoped Checking Contexts Forms]
All minimally scoped contexts, have the following forms. Defined by a judgement: $\Gamma \vdash \C^\F$ checks $e$ against $\tau$. With the meaning: $\C^\F$ is a minimally scoped checking context for $\analysis{e}{\tau}$. Defined:
\[\inference{\analysis{e}{\tau}}{\Gamma \vdash (\cmark : \tau)^{\mathrm{id}} \text{ checks } e \text{ against } \tau} \qquad \inference{\analysis{e_2}{\tau} & \synthesis{e_1}{\tau_1} & \tau_1 \funmatch \tau_2 \to \tau}{\Gamma \vdash (e_1(\cmark))^{\mathrm{id}} \text{ checks } e_2 \text{ against } \tau_2}\]
\[\inference{\Gamma \vdash \C^\F \text{ checks } \lambda x.\ e \text{ against } \tau & \tau \funmatch \tau_1 \to \tau_2}{\Gamma, x:\tau_1 \vdash \C^\F \circ (\lambda x.\ \cmark)^{\Gamma \mapsto \Gamma\backslash x:\tau_1} \text{ checks } e \text{ against } \tau_2}\]
\end{proposition}
\begin{proof}
Verify that each rule is a checking context, this follows very directly from the Hazel typing rules. No rule has a sub-context also being a checking context by induction, with the base cases being trivial: there is only one sub-context for the base case rules, $\cmark$, which is by definition not a checking context.
\end{proof}

\begin{proposition}[Checking Context of a Sub-term in a Derivation]
\label{def:CheckingContextInProgram}
If derivation $\synthesis{e}{\tau}$ contains a analysis sub-derivation $\analysis[\Gamma']{e'}{\tau'}$ for sub-term $e'$. Then there is a unique minimally scoped context $\C$ for $e'$ and typing assumption context $\F$ for $\Gamma'$ such that:
\begin{itemize}
\item $\C\{e'\}$ is a sub-term of $e$, or is $e$ itself.
\item Derivation $\synthesis{e}{\tau}$ contains a sub-derivation for $\synthesis[\F(\Gamma')]{\C\{e'\}}{\tau''}$, or is the derivation itself: $\tau'' = \tau, \C\{e'\} = e,$ and $\F(\Gamma') = \Gamma$.
\end{itemize}
\end{proposition}
\begin{proof}
Every minimally scoped checking context for $e'$ has a different structure. Hence, only one of these matches with the structure of $e'$ in $e$. You simply need to verify that one always exists (induction on the typing derivation), and that $\F(\Gamma') = \Gamma$ when $\C(e') = e$.
\end{proof}

\section{Criterion 1: Synthesis Slices}
\label{sec:SynthesisSlicesJudgement}
\begin{definition}[Synthesis Slices]
For a synthesising expression, $synthesis{e}{\tau}$. A synthesis slice is an expression typing slice $\varsigma^{\gamma}$ of $e^\Gamma$ which also synthesises $\tau$, that is, $\synthesis[\type{\gamma}]{\type{\varsigma}}{\tau}$.
\end{definition}
\begin{proposition}[Minimum Synthesis Slices]
A minimum synthesis slice of $e^\Gamma$ is a synthesis slice $\rho$ such that any other synthesis slices $\rho'$ are at least as specific, $\rho \sqsubseteq \rho'$. This minimum always uniquely exists.
\end{proposition}
\begin{proof}
Existence follows from bounded lattice structure, uniqueness follows from the uniqueness of typing in Hazel.
\end{proof}

\begin{figure}[H]
\fbox{$\synthesisslice{e}{\tau}{\S}$}\ \ \ $e$ synthesising type $\tau$ under context $\Gamma$ produces minimum type-indexed synthesis slice $\S$
\[\inference[\tiny SConst]{}{\synthesisslice{c}{b}{c^\emptyset}} \quad
\inference[\tiny SVar]{x : \tau \in \Gamma}{\synthesisslice{x}{\tau}{[x\mid x:\tau]}} \quad
\inference[\tiny SVar?]{x : \dyn \in \Gamma}{\synthesisslice{x}{\tau}{[\gap\mid \emptyset]}}\]
\[\inference[\tiny SFun]{\synthesisslice[\Gamma,x:\tau_1]{e}{\tau_2}{[\varsigma \mid \gamma, x : \tau_1]} }{\synthesisslice{\lambda x:\tau_1.\ e}{\tau_1 \to \tau_2}{[\lambda x : \tau_1.\ \varsigma \mid \gamma]}}\]
\[\inference[\tiny SFunConst]{\synthesisslice[\Gamma,x:\tau_1]{e}{\tau_2}{[\varsigma \mid \gamma]} & x \not \in \mathrm{dom}(\gamma)}{\synthesisslice{\lambda x:\tau_1.\ e}{\tau_1 \to \tau_2}{[\lambda \gap : \tau_1.\ \varsigma \mid \gamma]}}\]
\[\inference[\tiny SApp]{\synthesisslice{e_1}{\tau_1}{[\varsigma_1 \mid \gamma_1]}}{\synthesis{e_1(e_2)}{\tau}{[\varsigma_1(\gap) \mid \gamma_1]}} \quad 
\inference[\tiny SEHole]{}{\synthesisslice{\hole^u}{\dyn}{[\gap \mid \emptyset]}}\]
\[\inference[\tiny SNEHole]{\synthesisslice{e}{\tau}}{\synthesis{\hole[e]^u}{\dyn}{[\gap, \emptyset]}}\quad 
\inference[\tiny SAsc]{\analysis{e}{\tau}}{\synthesisslice{e : \tau}{\tau}{[\gap : \tau \mid \emptyset]}}\]

\caption{\textit{Minimum synthesis slice} calculation}
\label{fig:SynthesisSlices}
\end{figure} 


\begin{conjecture}[Correctness]
\label{conj:SynthesisSliceCorrectness}
If $\synthesis{e}{\tau}$ then:
\begin{itemize}
\item $\synthesisslice{e}{\tau}{\rho}$ where $\rho = \varsigma^\gamma$ with $\synthesis[\gamma]{\varsigma}{\tau}$.
\item For any $\rho' = \varsigma'^{\gamma'} \sqsubseteq e^\Gamma$ such that $\synthesis[\gamma']{\varsigma'}{\tau}$ then $\rho \sqsubseteq \rho'$.
\end{itemize}
\end{conjecture}

\section{Criterion 2: Analysis Slices}
\begin{definition}[Analysis Slice]\label{def:analysisslice}
For a term $e$ analysing against $\tau$: $\analysis{e}{\tau}$, and a minimally scoped checking context $\C^\F$ for $e$. An analysis slice is a slice $\Cs^\f$ of $\C^\F$ which is also a checking context for $e$. That is:
\begin{itemize}
\item $\synthesis[\f(\Gamma)]{\Cs\{e\}}{\tau'}$ for some $\tau'$.
\item The above derivation has a sub-derivation for $\analysis{e}{\tau}$. 
\end{itemize}
\end{definition}
\begin{conjecture}[Minimum Analysis Slices]\label{conj:AnalysisSliceUniqueness}
The minimum analysis slice analysing $e$ in a checking context $\C^\F$ is an analysis slice $\p$ such that for any other any other analysis slice $\p'$ is at least as specific, $\p \sqsubseteq \p'$. This minimum always uniquely exists.
\end{conjecture}

\begin{figure}[h]
TODO
\caption{\textit{Minimum analysis slice} calculation}
\label{fig:AnalsisSlices}
\end{figure}

\begin{conjecture}[Correctness]\label{conj:AnalysisSliceCorrectness}
If $\C$ is a checking context for $e$ and $\analysis{e}{\tau}$. Then $\analysisslice{\C}{e}{\tau}{\S}$ and $\S$ is the minimum analysis slice of $e$.
\end{conjecture}

\section{Criterion 3: Contribution Slices}

\begin{definition}[Contribution Slices]\label{def:ContributionSlice}
For $\synthesis{e}{\tau}$ containing sub-derivation $\analysis[\Gamma']{e'}{\tau'}$ with checking context $\C$.

A \textit{contribution slice} of $e'$ is an \textit{analysis slice} for $e'$ in $\C$ paired with an expression typing slice $\varsigma^\gamma$ such that:
\begin{itemize}
\item $\varsigma$ is a slice of $e'$, that $\varsigma \sqsubseteq e'$.
\item Under restricted typing context $\gamma$, that $\varsigma$ checks against any $\tau'_2$ at least as precise as $\tau'$:\footnote{Essentially, sub-terms that check against $\dyn$ also synthesise $\dyn$. Defined this way to include the case of unannotated lambdas (which do not synthesise).}
\[\forall \tau'_2.\ \tau' \sqsubseteq \tau'_2 \implies \analysis[\gamma]{e'}{\tau'_2}\]
\end{itemize}
A contribution slice for a sub-term $e''$ involved in sub-derivation $\synthesis[\Gamma'']{e''}{\tau''}$ where $e'' \neq e'$ is an expression typing slice $\varsigma''^{\gamma''}$ which also synthesises $\tau''$ under $\gamma''$, that $\synthesis[\gamma'']{\varsigma''}{\tau''}$. Further, any sub-term of $e''$ which has a contribution slice of the above variety, is replaced inside $\varsigma$ by that corresponding expression typing slice.
\end{definition} 
The synthetic parts of these slices can be calculated in exactly the same way as synthesis slices, except now also considering the \textit{subsumption} rule. The analytic parts are regular analysis slices.

The subsumption rule synthesises a type for some term, then checks consistency with the checked type. This is where the dynamic portions can be omitted, to give a contribution slice for the checked term. Representing contribution slices with the judgement $\contributionslice{e}{\tau}{\S}$ and $\contributionanalysisslice{\C}{e}{\tau}{\S_e}{\S_c}$, where $\S_e$ is the expression slice part and $\S_c$ is the contextual part:

\[\inference{\contributionslice{e}{\tau}{\S_s} & \tau \sim \tau' & \analysisslice{\C}{e}{\tau'}{\S_c}}{\contributionanalysisslice{\C}{e}{\tau'}{\mathrm{static}(\S_c, \S_s)}{\S_c}}\]
Where static is takes omits the \textit{right} (synthetic) slice parts where \textit{left} (analytic) slice is a leaf but the right is not. As the types are consistent, these leaves will be the unknown type. This means that portions of the synthetic part of the slice which match against $\dyn$ will be omitted: \textbf{SHOW A DIAGRAM}
\[\mathrm{static}(\p, \p') = \p'\]
\[\mathrm{static}(\p, \_ \to \_) = \gap^\emptyset\]
\[\mathrm{static}(\Cs_1 * \S_1 \to Cs_2 * \S_2,\ \Cs_1' * \S_1' \to Cs_2' * \S_2') = \Cs_1 * \mathrm{static}(\S_1, \S_1') \to \Cs_2' * \mathrm{static}(\S_2, \S_2')\]


\section{Elaboration}
\label{sec:CastSlicingElaboration}

