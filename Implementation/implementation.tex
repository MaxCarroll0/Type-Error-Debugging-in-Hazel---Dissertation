\chapter{Implementation}\label{chap:Implementation}
This project was conducted in two major phases:

First, I constructed a core mathematical theory for \textit{type slicing} and \textit{cast slicing} formalising what these ideas actually were and considered the changes to the system presented by Seidel et al. for the \textit{type error witnesses search procedure} to work in Hazel.  

Then, I implemented the theories, making it suitable for implementation and extending it to the majority of the Hazel language. Further, suitable deviations from the theory were made upon critical evaluation and are detailed throughout.

\textbf{Annotate the above with the relevant section links!}
\section{Type Slicing Theory}\label{sec:TypeSlicingTheory}

\subsection{Program Slices}
\subsection{Synthesis Type Slices}\label{sec:SynthesisSlices}
\subsection{Analysis Type Slices}\label{sec:AnalysisSlices}
Detail initial plan, then describe how this is nice and easy maths but not very useful

\section{Cast Slicing Theory}\label{sec:CastSlicingTheory}

\section{Proofs}\label{sec:Proofs}

\section{Type Slicing Implementation}\label{sec:TypeSlicingImplementation}
\subsection{Type Slice Data-Type}\label{sec:TypeSliceDataType}
Detail initial implementation (just tagging existing types).
\subsubsection{Code Slices}\label{sec:CodeSlices}
id based. Has ctx used but not actually required as I decide to directly store typslices in context (explain how this differs from the theory)
\subsubsection{Integration with Existing Type Data-Type}
\subsubsection{Synthesis \& Analysis Slices}
Incremental/Global. Detail the choice to not annotate many analysis slices
\subsubsection{Mapping Functions}
\subsubsection{Type Slice Joins}

\subsection{Static Type Checking}\label{sec:TypeChecking}


\subsection{Elaboration}\label{sec:Elaboration}


\subsection{User Interface}

\section{Cast Slicing Implementation}\label{sec:CastSlicingImplementation}
\subsection{Cast Transitions}

\subsection{User Interface}
Mainly talk about the Model-view architecture and passing the cursor into the evaluator view to allow 

\section{Indeterminate Evaluation}\label{sec:IndetEval}
\subsection{Futures Data-Type}\label{sec:Futures}
\subsection{Hole Instantiation}\label{sec:HoleInstantiation}
Small Hole hypothesis, quick check
\subsubsection{Choosing which Hole to Instantiate}
\subsubsection{Synthesising Terms for Types}
\subsubsection{Substituting Holes}\label{sec:HoleSubstitutionImplementation}
Detail that this was an unexpected extra task, and is therefore not exactly the same as hole substitution as detailed in Preparation (i.e. no metavars or contexts annotated on holes, but it is enough for the search procedure to work)
\subsection{Cast Laziness}\label{sec:CastLaziness}
Ref the original cast slicing paper.
\subsection{User Interface}

\section{Evaluation Stepper}\label{sec:Stepper}
\subsection{Customisable Hole Instantiation}
\subsection{User Interface}


\section{Search Procedure}\label{sec:SearchProcedure}
\subsection{Detecting Relevant Cast Errors}
i.e. failed cast at head of term
\subsection{Filtering Indeterminate Evaluation}

\subsection{Iterative Deepening}\label{sec:IterativeDeepening}
Required after evaluating that infinite loops break the thing
\subsection{User Interface}


