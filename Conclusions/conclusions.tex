\chapter{Conclusions}\label{chap:Conclusions}

\section{Conclusion}
Conclusions Here.

\section{Further Directions}
Further directions here, referencing unsatisfactory results from Evaluation. Also various extensions.
\subsection{Extension to Full Hazel Language}
Type functions, recursive types, deferrals

\subsection{Cast Slicing}
Cast slicing here doesn't extend the nice properties I have with type slicing: that a program slice will synthesise/analyse the same type. It might be possible to have a system that does?

The implementation differs by storing slices directly in the context, making analysis slices.

Also, the fact that cast slices are manipulated in evaluation is completely opaque to the user \textit{unless} they step through manually. Ways to better represent this information exist (cast dependency graphs etc.)

\subsubsection{Proofs}
PRimarily about the search procedure \& casts. 

Also about creating a \textit{stronger} link between static type errors and runtime errors, what Hazel considers as a runtime error is somewhat unintuitive, see the points made in evaluation. A formal property of what exactly a type error witness \textit{is} which actually matches with the implementation would be nice.

\subsubsection{User Studies}
Effectiveness gauge in the real world

\subsection{Search Procedure}
\subsubsection{Jump Trace Compression}
\subsubsection{Symbolic Execution \& SMT Solvers}
\subsubsection{Ad-Hoc Polymophism}
Not in Hazel, but the search procedure can't deal well with it
\subsubsection{Formal Semantics \& Proofs}
Was an uncompleted extension goal

\subsection{Let Polymorphism \& Global Inference}
Errors with global inference errors are often more subtle, where trace visualisation really shines. 
\subsubsection{Constraint Slicing}
To allow slices to work with constraint solvers. One error slicing paper already does this.

\subsubsection{Gradual Type Inference}
Miyazaki has a good paper on this. Seems like it could work well in Hazel, though at the loss of parametricity.

\subsubsection{Localisation}
Bidirectional typing localisation is good, but global inference is bad. The search procedure could improve localisation and also give more meaning (traces, slices) to localisations.