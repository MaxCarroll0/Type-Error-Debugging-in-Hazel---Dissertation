\chapter{Introduction}
\label{chap:Introduction}
Software bugs are an inherent part of programming, often leading to unexpected behaviour and system failures. Debugging these errors is a \textit{time-consuming process} taking between 20-60\% of active work time \cite{DebugTimeSelfReport}, with programmers spending a \textit{highly skewed} proportion of their time identifying and resolving a small proportion of \textit{difficult} bugs \cite{DebugSkew}.

Type systems aim to alleviate some of this burden by classifying expressions and operations that are allowed to work on them. This may be done \textit{statically} at compile time or \textit{dynamically} during runtime. The expressions not conforming to the type system manifest themselves as \textit{type errors}.

In static typing, blame for type errors are typically localised to a \textit{single} location in the code. However, this localisation may be misleading, as the actual cause of the error might be rooted in a broader context, for example in OCaml 65\% of type errors related to \textit{multiple} locations \cite{StudentTypeErrorFixes}. This is a particularly prevalent issue in \textit{type inferred} languages.

In dynamic typing, type errors are often missed as they only appear during runtime with specific inputs. However, a dynamic type error can be more intuitive due to it being accompanied by an \textit{evaluation trace} demonstrating concretely why values are \textit{not} consistent with their expected type.

This project seeks to enhance the debugging experience in Hazel \cite{Hazel}, a functional locally inferred and gradually typed research language under active development at the University of Michigan. 

\textbf{INTRODUCE HAZEL \& IT'S VISION HERE WITH IT'S BASIC UNUSUAL FEATURES}

I introduce two novel features to improve user comprehension of type errors, \textit{type slicing} and \textit{cast slicing}; additionally, mathematical foundations have been devised for these by building upon the Hazel Calculus \cite{HazelLivePaper}. Further, I implement a \textit{type error witness search procedure} based upon a similar idea implemented for a subset of OCaml by Seidel et al. \cite{SearchProc}:
\begin{itemize}
\item \textbf{Type slicing} highlights larger sections of code that contribute to an expression having a required type. Hence, a \textit{static type error} location can be selected and the context enforcing the erroneous type revealed.

\item \textbf{Cast slicing} propagates type slice information throughout evaluation, allowing the context of \textit{runtime casts} to be examined. Hence, a \textit{runtime type error} (that is, a \textit{cast error}) can be selected to reveal the context enforcing it's expected type.

\item The \textbf{type error witness search procedure} finds inputs to expressions that will cause a \textit{cast error} upon evaluation, these accompanied with their execution trace are referred to as \textit{type error witnesses}. Hence, dynamic type errors can be found automatically, and \textit{concrete} type witnesses can be found for known static type errors.
\end{itemize}

These three features work well together to allow both static and dynamic type errors to be located and explained to a greater extent than in any existing languages. Arguably, these explanations are intuitive, and should help reduce debugging times and aid in students understanding type systems.

For example, here is a walk-through for how a simple error could be diagnosed using these three features. 

\textbf{MAP function? show a static error version}

\section{Related Work}
\label{sec:RelatedWork}
There has been extensive research into attempting to understand \textit{what} is needed \cite{DebugNeeds}, \textit{how} developers fix bugs \cite{HowFixBugs}, and a plethora of compiler \textit{improvements} and \textit{tools} \textbf{add citations here, primarily functional language tools}. This project builds upon this body of research in new ways focusing on the Hazel language, which is itself a research project being taken in various directions but generally as a \textit{teaching language} for students. 

To my knowledge the ideas of \textit{type slicing} and \textit{cast slicing} are novel. However, they do output \textit{program slices} which were originally explored by Weiser \cite{ProgSlice}, though my definition of program slices matches more with functional program slices \cite{FunctionalProgExplain}, and the properties I explore are more similar to \textit{dynamic program slicing} \cite{DynProgSlice} but with type characteristics rather than evaluation characteristics, in a sense similar \textit{type error slicing} \cite{ErrSlice}.

The \textit{type witness search procedure} is	 based upon Seidel et al. \cite{SearchProc}, though there are significant differences in workings due to my use of Hazel and various extensions as compared to the subset of OCaml used by Seidel et al.

\section{Dissertation Outline}
\label{sec:Outline}
\Cref{chap:Preparation} introduces the \textit{type theories} (\cref{sec:TypeSystems}) underpinning the \textit{Hazel core calculus} (\cref{sec:CoreHazel}), followed by the \textit{Hazel implementation} (\cref{sec:HazelImplementation}).

\Cref{sec:TypeSlicingTheory} and \cref{sec:CastSlicingTheory} formalise the ideas of \textit{type slices} and \textit{cast slices} in the Hazel core calculus, with properties proven\footnote{\textbf{TODO}} in \cref{sec:Proofs}. 
 
 An implementation (\cref{sec:TypeSlicingImplementation}-\ref{sec:CastSlicingImplementation}) of these has been created covering \textit{most}\footnote{Except for type substitution.} of the Hazel language, including a user interface. 
 
 A \textit{type witness search procedure} was successfully implemented. This involved creating a \textit{hole instantiation} and a simplified \textit{hole substitution} method (\cref{sec:HoleInstantiation}); there is currently no full hole substitution feature in Hazel despite it's presence in the core calculus (\cref{sec:HoleSubstitution}). Additionally, a customisable instantiation method was implemented (\cref{sec:Stepper}) controllable via a UI.

The slicing features and search procedure met all goals, \textbf{list eval goals briefly}, showing \textit{effectiveness} (\cref{sec:EffectivenessAnalysis}) and being reasonably \textit{performant} (\cref{sec:PerformanceAnalysis}) over a corpus of \textit{well-typed} and \textit{ill-typed} Hazel programs respectively (\cref{sec:CorpusCollection}). Further, considered deviations from the slicing theories and strengths and weaknesses of the search procedure were evaluated in detail (\cref{sec:CriticalAnalysis}).

Finally, further directions and improvements have been presented along with discussion on the applicability of these features, slicing in particular, to real world debugging situations in \cref{chap:Conclusions}.