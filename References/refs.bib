@inproceedings{SearchProc,
  series = {ICFP’16},
  title = {Dynamic witnesses for static type errors (or,  ill-typed programs usually go wrong)},
  url = {http://dx.doi.org/10.1145/2951913.2951915},
  DOI = {10.1145/2951913.2951915},
  booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
  publisher = {ACM},
  author = {Seidel,  Eric L. and Jhala,  Ranjit and Weimer,  Westley},
  year = {2016},
  month = sep,
  pages = {228–242},
  collection = {ICFP’16}
}

@online{Hazel,
title = {Hazel Project Website},
url = {https://hazel.org/},
urldate = {2025-02-28},
}


@online{CurryLang,
title = {The Curry Programming Language},
url = {https://curry-lang.org/},
urldate = {2025-04-16},
}

@online{Mercury,
title = {Mercury Reference Manual: Clauses},
url = {https://mercurylang.org/information/doc-latest/mercury_ref/Clauses.html#Overview-of-Mercury-semantics},
urldate = {2025-04-12},
}

@online{EffectsExamples,
title = {OCaml Effects Examples},
url = {https://github.com/ocaml-multicore/effects-examples/tree/master},
urldate = {2025-03-26}
}

@inproceedings{HandlersInAction,
author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
title = {Handlers in action},
year = {2013},
isbn = {9781450323260},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2500365.2500590},
doi = {10.1145/2500365.2500590},
abstract = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
pages = {145–158},
numpages = {14},
keywords = {algebraic effects, continuations, effect handlers, effect typing, haskell, modularity, monads},
location = {Boston, Massachusetts, USA},
series = {ICFP '13}
}


@manual{OCamlManual,
  title        = {The OCaml Manual: release 5.2},
  author       = {The OCaml Development Team},
  year         = {2024},
  url          = {https://ocaml.org/manual/5.2/index.html},
  urldate         = {2025-02-28}
}
@online{HazelCode,
title = {Hazel Source Code},
url = {https://github.com/hazelgrove/hazel},
urldate = {2025-02-28},
}

@online{ConcurrentZipper,
title = {Generic Zippers},
url = {https://okmij.org/ftp/continuations/zipper.html},
author = {Oleg Kiselyov}
}

@online{MultiZipper,
title = {Multi Zippers},
url = {https://pavpanchekha.com/blog/zippers/multi-zippers.html#org1556357},
author = {Pavel Panchekha}
}

@online{DelimitedControl,
title = {Delimited Control in OCaml},
url = {https://okmij.org/ftp/continuations/implementations.html},
author = {Oleg Kiselyov}
}

@inproceedings{ShiftReset,
author = {Danvy, Olivier and Filinski, Andrzej},
title = {Abstracting control},
year = {1990},
isbn = {089791368X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/91556.91622},
doi = {10.1145/91556.91622},
abstract = {The last few years have seen a renewed interest in continuations for expressing advanced control structures in programming languages, and new models such as Abstract Continuations have been proposed to capture these dimensions. This article investigates an alternative formulation, exploiting the latent expressive power of the standard continuation-passing style (CPS) instead of introducing yet other new concepts. We build on a single foundation: abstracting control as a hierarchy of continuations, each one modeling a specific language feature as acting on nested evaluation contexts.We show how iterating the continuation-passing conversion allows us to specify a wide range of control behavior. For example, two conversions yield an abstraction of Prolog-style backtracking. A number of other constructs can likewise be expressed in this framework; each is defined independently of the others, but all are arranged in a hierarchy making any interactions between them explicit.This approach preserves all the traditional results about CPS, e.g., its evaluation order independence. Accordingly, our semantics is directly implementable in a call-by-value language such as Scheme or ML. Furthermore, because the control operators denote simple, typable lambda-terms in CPS, they themselves can be statically typed. Contrary to intuition, the iterated CPS transformation does not yield huge results: except where explicitly needed, all continuations beyond the first one disappear due to the extensionality principle (η-reduction).Besides presenting a new motivation for control operators, this paper also describes an improved conversion into applicative-order CPS. The conversion operates in one pass by performing all administrative reductions at translation time; interestingly, it can be expressed very concisely using the new control operators. The paper also presents some examples of nondeterministic programming in direct style.},
booktitle = {Proceedings of the 1990 ACM Conference on LISP and Functional Programming},
pages = {151–160},
numpages = {10},
location = {Nice, France},
series = {LFP '90}
}

@article{Extensionality,
 ISSN = {00264423, 14602113},
 URL = {http://www.jstor.org/stable/2251588},
 author = {Ruth Barcan Marcus},
 journal = {Mind},
 number = {273},
 pages = {55--62},
 publisher = {[Oxford University Press, Mind Association]},
 title = {Extensionality},
 urldate = {2025-04-16},
 volume = {69},
 year = {1960}
}

@book{Lattice,
  title={Lattice theory},
  author={Birkhoff, Garrett},
  volume={25},
  year={1940},
  publisher={American Mathematical Soc.}
}



@inbook{Blame,
  title = {Well-Typed Programs Can’t Be Blamed},
  ISBN = {9783642005909},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-642-00590-9_1},
  DOI = {10.1007/978-3-642-00590-9_1},
  booktitle = {Programming Languages and Systems},
  publisher = {Springer Berlin Heidelberg},
  author = {Wadler,  Philip and Findler,  Robert Bruce},
  year = {2009},
  pages = {1–16}
}

@article{ErrSlice,
  title = {A slicing-based approach for locating type errors},
  volume = {10},
  ISSN = {1557-7392},
  url = {http://dx.doi.org/10.1145/366378.366379},
  DOI = {10.1145/366378.366379},
  number = {1},
  journal = {ACM Transactions on Software Engineering and Methodology},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Tip,  F. and Dinesh,  T. B.},
  year = {2001},
  month = jan,
  pages = {5–55}
}

@article{HaackErrSlice,
  title = {Type error slicing in implicitly typed higher-order languages},
  volume = {50},
  ISSN = {0167-6423},
  url = {http://dx.doi.org/10.1016/j.scico.2004.01.004},
  DOI = {10.1016/j.scico.2004.01.004},
  number = {1–3},
  journal = {Science of Computer Programming},
  publisher = {Elsevier BV},
  author = {Haack,  Christian and Wells,  J.B.},
  year = {2004},
  month = mar,
  pages = {189–224}
}

@inbook{ConstraintFreeErrSlice,
  title = {Constraint-Free Type Error Slicing},
  ISBN = {9783642320378},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-642-32037-8_1},
  DOI = {10.1007/978-3-642-32037-8_1},
  booktitle = {Trends in Functional Programming},
  publisher = {Springer Berlin Heidelberg},
  author = {Schilling,  Thomas},
  year = {2012},
  pages = {1–16}
}

@article{DynProgSlice,
  title = {Dynamic program slicing},
  volume = {29},
  ISSN = {0020-0190},
  url = {http://dx.doi.org/10.1016/0020-0190(88)90054-3},
  DOI = {10.1016/0020-0190(88)90054-3},
  number = {3},
  journal = {Information Processing Letters},
  publisher = {Elsevier BV},
  author = {Korel,  Bogdan and Laski,  Janusz},
  year = {1988},
  month = oct,
  pages = {155–163}
}
@inproceedings{ProgSlice,
author = {Weiser, Mark},
title = {Program slicing},
year = {1981},
isbn = {0897911466},
publisher = {IEEE Press},
abstract = {Program slicing is a method used by experienced computer programmers for abstracting from programs. Starting from a subset of a program's behavior, slicing reduces that program to a minimal form which still produces that behavior. The reduced program, called a “slice”, is an independent program guaranteed to faithfully represent the original program within the domain of the specified subset of behavior.Finding a slice is in general unsolvable. A dataflow algorithm is presented for approximating slices when the behavior subset is specified as the values of a set of variables at a statement. Experimental evidence is presented that these slices are used by programmers during debugging. Experience with two automatic slicing tools is summarized. New measures of program complexity are suggested based on the organization of a program's slices.},
booktitle = {Proceedings of the 5th International Conference on Software Engineering},
pages = {439–449},
numpages = {11},
keywords = {Data flow analysis, Debugging, Human factors, Program maintenance, Program metrics, Software tools},
location = {San Diego, California, USA},
series = {ICSE '81}
}


@article{HazelLivePaper,
  title = {Live functional programming with typed holes},
  volume = {3},
  ISSN = {2475-1421},
  url = {http://dx.doi.org/10.1145/3290327},
  DOI = {10.1145/3290327},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Omar,  Cyrus and Voysey,  Ian and Chugh,  Ravi and Hammer,  Matthew A.},
  year = {2019},
  month = jan,
  pages = {1–32}
}

@inbook{StandardMLTypeTheory,
  title = {A Type-Theoretic Interpretation of Standard ML},
  ISBN = {9780262281676},
  url = {http://dx.doi.org/10.7551/mitpress/5641.003.0019},
  DOI = {10.7551/mitpress/5641.003.0019},
  booktitle = {Proof,  Language,  and Interaction},
  publisher = {The MIT Press},
  author = {Harper,  Robert and Stone,  Christopher},
  year = {2000},
  month = may,
  pages = {341–388}
}

@article{CoreXML,
  title = {On the type structure of standard ML},
  volume = {15},
  ISSN = {1558-4593},
  url = {http://dx.doi.org/10.1145/169701.169696},
  DOI = {10.1145/169701.169696},
  number = {2},
  journal = {ACM Transactions on Programming Languages and Systems},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Harper,  Robert and Mitchell,  John C.},
  year = {1993},
  month = apr,
  pages = {211–252}
}

@article{LocalInference,
  title = {Local type inference},
  volume = {22},
  ISSN = {1558-4593},
  url = {http://dx.doi.org/10.1145/345099.345100},
  DOI = {10.1145/345099.345100},
  number = {1},
  journal = {ACM Transactions on Programming Languages and Systems},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Pierce,  Benjamin C. and Turner,  David N.},
  year = {2000},
  month = jan,
  pages = {1–44}
}

@inproceedings{BidirectionalTypes,
  series = {ICFP’13},
  title = {Complete and easy bidirectional typechecking for higher-rank polymorphism},
  url = {http://dx.doi.org/10.1145/2500365.2500582},
  DOI = {10.1145/2500365.2500582},
  booktitle = {Proceedings of the 18th ACM SIGPLAN international conference on Functional programming},
  publisher = {ACM},
  author = {Dunfield,  Jana and Krishnaswami,  Neelakantan R.},
  year = {2013},
  month = sep,
  collection = {ICFP’13}
}

@inbook{GradualObjects,
  title = {Gradual Typing for Objects},
  ISBN = {9783540735892},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-540-73589-2_2},
  DOI = {10.1007/978-3-540-73589-2_2},
  booktitle = {ECOOP 2007 – Object-Oriented Programming},
  publisher = {Springer Berlin Heidelberg},
  author = {Siek,  Jeremy and Taha,  Walid},
  year = {2007},
  pages = {2–27}
}

@inbook{GradualFunctional,
  title = {Gradual Typing for Functional Languages},
  author = {Jeremy G. Siek and Walid Taha},
  booktitle = {Scheme and Functional Programming Workshop},
  pages = {81-92},
  year = {2006}
}

@inproceedings{GradualRefined,
  title={Refined Criteria for Gradual Typing},
  author={Jeremy G. Siek and Michael M. Vitousek and Matteo Cimini and John Tang Boyland},
  booktitle={Summit on Advances in Programming Languages},
  year={2015},
  url={https://api.semanticscholar.org/CorpusID:15383644}
}

@book{PracticalFoundations,
  title = {Practical Foundations for Programming Languages: Second Edition},
  ISBN = {9781316576892},
  url = {http://dx.doi.org/10.1017/CBO9781316576892},
  DOI = {10.1017/cbo9781316576892},
  publisher = {Cambridge University Press},
  author = {Harper,  Robert},
  year = {2016},
  month = mar 
}

@article{CMTT,
  title = {Contextual modal type theory},
  volume = {9},
  ISSN = {1557-945X},
  url = {http://dx.doi.org/10.1145/1352582.1352591},
  DOI = {10.1145/1352582.1352591},
  number = {3},
  journal = {ACM Transactions on Computational Logic},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Nanevski,  Aleksandar and Pfenning,  Frank and Pientka,  Brigitte},
  year = {2008},
  month = jun,
  pages = {1–49}
}

@article{ModalStagedComputation,
author = {Davies, Rowan and Pfenning, Frank},
title = {A modal analysis of staged computation},
year = {2001},
issue_date = {May 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {3},
issn = {0004-5411},
url = {https://doi.org/10.1145/382780.382785},
doi = {10.1145/382780.382785},
abstract = {We show that a type system based on the intuitionistic modal logic S4 provides an expressive framework for specifying and analyzing computation stages in the context of typed λ-calculi and functional languages. We directly demonstrate the sense in which our λe→□-calculus captures staging, and also give a conservative embeddng of Nielson and Nielson's two-level functional language in our functional language Mini-ML□, thus proving that binding-time correctness is equivalent to modal correctness on this fragment. In addition, Mini-ML□ can also express immediate evaluation and sharing of code across multiple stages, thus supporting run-time code generation as well as partial evaluation.},
journal = {J. ACM},
month = may,
pages = {555–604},
numpages = {50},
keywords = {staged computation, run-time code generation, binding times}
}

@article{ModalJudgements,
  title = {A judgmental reconstruction of modal logic},
  volume = {11},
  ISSN = {1469-8072},
  url = {http://dx.doi.org/10.1017/S0960129501003322},
  DOI = {10.1017/s0960129501003322},
  number = {04},
  journal = {Mathematical Structures in Computer Science},
  publisher = {Cambridge University Press (CUP)},
  author = {Pfenning,  Frank and Davies,  Rowan},
  year = {2001},
  month = jul 
}

@article{FunctionalProgExplain,
  title = {Functional programs that explain their work},
  volume = {47},
  ISSN = {1558-1160},
  url = {http://dx.doi.org/10.1145/2398856.2364579},
  DOI = {10.1145/2398856.2364579},
  number = {9},
  journal = {ACM SIGPLAN Notices},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Perera,  Roly and Acar,  Umut A. and Cheney,  James and Levy,  Paul Blain},
  year = {2012},
  month = sep,
  pages = {365–376}
}

@article{MarkedLocalisation,
  title = {Total Type Error Localization and Recovery with Holes},
  volume = {8},
  ISSN = {2475-1421},
  url = {http://dx.doi.org/10.1145/3632910},
  DOI = {10.1145/3632910},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Zhao,  Eric and Maroof,  Raef and Dukkipati,  Anand and Blinn,  Andrew and Pan,  Zhiyi and Omar,  Cyrus},
  year = {2024},
  month = jan,
  pages = {2041–2068}
}

@misc{GradualJoins,
      title={Parameterized Cast Calculi and Reusable Meta-theory for Gradually Typed Lambda Calculi}, 
      author={Jeremy G. Siek},
      year={2021},
      eprint={2001.11560},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2001.11560}, 
}

@misc{Bechamel, 
    title={Bechamel Micro Benchmarking Library},
    year={2025},
    url={https://github.com/mirage/bechamel}}

@inproceedings{Gradualizer,
  series = {POPL ’16},
  title = {The gradualizer: a methodology and algorithm for generating gradual type systems},
  url = {http://dx.doi.org/10.1145/2837614.2837632},
  DOI = {10.1145/2837614.2837632},
  booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  publisher = {ACM},
  author = {Cimini,  Matteo and Siek,  Jeremy G.},
  year = {2016},
  month = jan,
  pages = {443–455},
  collection = {POPL ’16}
}

@Inbook{Prolog,
author="Warren, David S.",
editor="Warren, David S.
and Dahl, Veronica
and Eiter, Thomas
and Hermenegildo, Manuel V.
and Kowalski, Robert
and Rossi, Francesca",
title="Introduction to Prolog",
bookTitle="Prolog: The Next 50 Years",
year="2023",
publisher="Springer Nature Switzerland",
address="Cham",
pages="3--19",
abstract="This first chapter of the Prolog50 book is brief introduction to the Prolog programming language. It is intended to provide background knowledge that will help in the understanding of many of the papers here. It covers basic Prolog definitions, their procedural interpretation, the idea of predicate modes, bottom-up evaluation of definitions, negation including stratified and nonstratified definitions, tabled evaluation, Prolog's use of operators, program meta-interpretation, Definite Clause Grammars, and constraints. All topics are covered only briefly, and through the use of simple examples. For each topic there is much more to be said, some of which will be said in the papers in this volume.",
isbn="978-3-031-35254-6",
doi="10.1007/978-3-031-35254-6_1",
url="https://doi.org/10.1007/978-3-031-35254-6_1"
}



@inproceedings{GradualizerDynamic,
  series = {POPL ’17},
  title = {Automatically generating the dynamic semantics of gradually typed languages},
  volume = {7},
  url = {http://dx.doi.org/10.1145/3009837.3009863},
  DOI = {10.1145/3009837.3009863},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  publisher = {ACM},
  author = {Cimini,  Matteo and Siek,  Jeremy G.},
  year = {2017},
  month = jan,
  pages = {789–803},
  collection = {POPL ’17}
}

@book{TAPL,
author = {Pierce, Benjamin C.},
title = {Types and Programming Languages},
year = {2002},
isbn = {0262162091},
publisher = {The MIT Press},
edition = {1st},
abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@inproceedings{HashCons,
  series = {ICFP06},
  title = {Type-safe modular hash-consing},
  url = {http://dx.doi.org/10.1145/1159876.1159880},
  DOI = {10.1145/1159876.1159880},
  booktitle = {Proceedings of the 2006 workshop on ML},
  publisher = {ACM},
  author = {Filli\^atre,  Jean-Christophe and Conchon,  Sylvain},
  year = {2006},
  month = sep,
  collection = {ICFP06}
}
  
@article{Zipper,
  title = {The Zipper},
  volume = {7},
  ISSN = {1469-7653},
  url = {http://dx.doi.org/10.1017/S0956796897002864},
  DOI = {10.1017/s0956796897002864},
  number = {5},
  journal = {Journal of Functional Programming},
  publisher = {Cambridge University Press (CUP)},
  author = {HUET,  GÉRARD},
  year = {1997},
  month = sep,
  pages = {549–554}
}

@book{PurelyFunctionalDataStructures,
  title = {Purely Functional Data Structures},
  ISBN = {9780511530104},
  url = {http://dx.doi.org/10.1017/CBO9780511530104},
  DOI = {10.1017/cbo9780511530104},
  publisher = {Cambridge University Press},
  author = {Okasaki,  Chris},
  year = {1998},
  month = apr 
}    

@inbook{SemiPersistent,
  title = {Semi-persistent Data Structures},
  ISBN = {9783540787396},
  url = {http://dx.doi.org/10.1007/978-3-540-78739-6_25},
  DOI = {10.1007/978-3-540-78739-6_25},
  booktitle = {Programming Languages and Systems},
  publisher = {Springer Berlin Heidelberg},
  author = {Conchon,  Sylvain and Filli\^atre,  Jean-Christophe},
  pages = {322–336}
}

@article{WAM,
  title = "A Functional Derivation of the Warren Abstract Machine",
  author = "Maciej Pirog and Jeremy Gibbons",
  year = "2011",
  note = "Submitted for publication",
  url = "http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/wam.pdf",
}

@phdthesis{OLEG,
  title={Dependently typed functional programs and their proofs},
  author={McBride, Conor},
  year={2000},
  school={University of Edinburgh. College of Science and Engineering.}
}

@inproceedings{QuickCheck,
author = {Claessen, Koen and Hughes, John},
title = {QuickCheck: a lightweight tool for random testing of Haskell programs},
year = {2000},
isbn = {1581132026},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/351240.351266},
doi = {10.1145/351240.351266},
abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
booktitle = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
pages = {268–279},
numpages = {12},
series = {ICFP '00}
}

@article{SmallScopeHypothesis,
author = {Andoni, Alexandr and Daniliuc, Dumitru and Khurshid, Sarfraz and Marinov, Darko},
year = {2002},
month = {10},
pages = {},
title = {Evaluating the "Small Scope Hypothesis"}
}

@inproceedings{SmallScopeHypothesisAnswerSet,
author = {Oetsch, Johannes and Prischink, Michael and P\"{u}hrer, J\"{o}rg and Schwengerer, Martin and Tompits, Hans},
title = {On the small-scope hypothesis for testing answer-set programs},
year = {2012},
isbn = {9781577355601},
publisher = {AAAI Press},
abstract = {In software testing, the small-scope hypothesis states that a high proportion of errors can be found by testing a program for all test inputs within some small scope. In this paper, we evaluate the small-scope hypothesis for answer-set programming (ASP). To this end, we follow work in traditional testing and base our evaluation on mutation analysis. In fact, we show that a rather limited scope is sufficient for testing ASP encodings from a representative set of benchmark problems. Our experimental evaluation facilitates effective methods for testing in ASP. Also, it gives some justification to analyse programs at the propositional level after grounding them over a small domain.},
booktitle = {Proceedings of the Thirteenth International Conference on Principles of Knowledge Representation and Reasoning},
pages = {43–53},
numpages = {11},
location = {Rome, Italy},
series = {KR'12}
}

@inproceedings{SmallCheck,
author = {Runciman, Colin and Naylor, Matthew and Lindblad, Fredrik},
title = {Smallcheck and lazy smallcheck: automatic exhaustive testing for small values},
year = {2008},
isbn = {9781605580647},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411286.1411292},
doi = {10.1145/1411286.1411292},
abstract = {This paper describes two Haskell libraries for property-based testing. Following the lead of QuickCheck, these testing libraries SmallCheck and Lazy SmallCheck also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with QuickCheck.},
booktitle = {Proceedings of the First ACM SIGPLAN Symposium on Haskell},
pages = {37–48},
numpages = {12},
keywords = {embedded language, exhaustive search, lazy evaluation, property-based testing, type classes},
location = {Victoria, BC, Canada},
series = {Haskell '08}
}

@article{DTI,
author = {Miyazaki, Yusuke and Sekiyama, Taro and Igarashi, Atsushi},
title = {Dynamic type inference for gradual Hindley–Milner typing},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290331},
doi = {10.1145/3290331},
abstract = {Garcia and Cimini study a type inference problem for the ITGL, an implicitly and gradually typed language with let-polymorphism, and develop a sound and complete inference algorithm for it. Soundness and completeness mean that, if the algorithm succeeds, the input term can be translated to a well-typed term of an explicitly typed blame calculus by cast insertion and vice versa. However, in general, there are many possible translations depending on how type variables that were left undecided by static type inference are instantiated with concrete static types. Worse, the translated terms may behave differently—some evaluate to values but others raise blame. In this paper, we propose and formalize a new blame calculus λBDTI that avoids such divergence as an intermediate language for the ITGL. A main idea is to allow a term to contain type variables (that have not been instantiated during static type inference) and defer instantiation of these type variables to run time. We introduce dynamic type inference (DTI) into the semantics of λBDTI so that type variables are instantiated along reduction. The DTI-based semantics not only avoids the divergence described above but also is sound and complete with respect to the semantics of fully instantiated terms in the following sense: if the evaluation of a term succeeds (i.e., terminates with a value) in the DTI-based semantics, then there is a fully instantiated version of the term that also succeeds in the explicitly typed blame calculus and vice versa. Finally, we prove the gradual guarantee, which is an important correctness criterion of a gradually typed language, for the ITGL.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {18},
numpages = {29},
keywords = {dynamic type inference, gradual guarantee, gradual typing}
}

@inproceedings{GradualTI,
author = {Garcia, Ronald and Cimini, Matteo},
title = {Principal Type Schemes for Gradual Programs},
year = {2015},
isbn = {9781450333009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2676726.2676992},
doi = {10.1145/2676726.2676992},
abstract = {Gradual typing is a discipline for integrating dynamic checking into a static type system. Since its introduction in functional languages, it has been adapted to a variety of type systems, including object-oriented, security, and substructural. This work studies its application to implicitly typed languages based on type inference. Siek and Vachharajani designed a gradual type inference system and algorithm that infers gradual types but still rejects ill-typed static programs. However, the type system requires local reasoning about type substitutions, an imperative inference algorithm, and a subtle correctness statement.This paper introduces a new approach to gradual type inference, driven by the principle that gradual inference should only produce static types. We present a static implicitly typed language, its gradual counterpart, and a type inference procedure. The gradual system types the same programs as Siek and Vachharajani, but has a modular structure amenable to extension. The language admits let-polymorphism, and its dynamics are defined by translation to the Polymorphic Blame Calculus.The principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing. To expose this difference, we distinguish static type parameters from gradual type parameters and reinterpret gradual type consistency accordingly. The resulting extension enables programs to be interpreted using either the polymorphic or monomorphic Blame Calculi.},
booktitle = {Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {303–315},
numpages = {13},
keywords = {type inference, gradual typing},
location = {Mumbai, India},
series = {POPL '15}
}


@inproceedings{EffectsHaskell,
author = {Xie, Ningning and Leijen, Daan},
title = {Effect handlers in Haskell, evidently},
year = {2020},
isbn = {9781450380508},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3406088.3409022},
doi = {10.1145/3406088.3409022},
abstract = {Algebraic effect handlers offer an alternative to monads to incorporate effects in Haskell. In recent work Xie _et al._ show how to give semantics to effect handlers in terms of plain polymorphic lambda calculus through _evidence translation_. Besides giving precise semantics, this translation also allows for potentially more efficient implementations. Here we present the first implementation of this technique as a library for effect handlers in Haskell. We show how the design naturally leads to a concise effect interface and how evidence translation enables evaluating _tail resumptive_ operations _in-place_. We give detailed benchmark results where our library performs well with respect to other approaches.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Haskell},
pages = {95–108},
numpages = {14},
keywords = {Algebraic Effects, Evidence Passing Translation, Handlers},
location = {Virtual Event, USA},
series = {Haskell 2020}
}

@inproceedings{DebugTimeSelfReport,
author = {Beller, Moritz and Spruit, Niels and Spinellis, Diomidis and Zaidman, Andy},
title = {On the dichotomy of debugging behavior among programmers},
year = {2018},
isbn = {9781450356381},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3180155.3180175},
doi = {10.1145/3180155.3180175},
abstract = {Debugging is an inevitable activity in most software projects, often difficult and more time-consuming than expected, giving it the nickname the "dirty little secret of computer science." Surprisingly, we have little knowledge on how software engineers debug software problems in the real world, whether they use dedicated debugging tools, and how knowledgeable they are about debugging. This study aims to shed light on these aspects by following a mixed-methods research approach. We conduct an online survey capturing how 176 developers reflect on debugging. We augment this subjective survey data with objective observations on how 458 developers use the debugger included in their integrated development environments (IDEs) by instrumenting the popular Eclipse and IntelliJ IDEs with the purpose-built plugin WatchDog 2.0. To clarify the insights and discrepancies observed in the previous steps, we followed up by conducting interviews with debugging experts and regular debugging users. Our results indicate that IDE-provided debuggers are not used as often as expected, as "printf debugging" remains a feasible choice for many programmers. Furthermore, both knowledge and use of advanced debugging features are low. These results call to strengthen hands-on debugging experience in computer science curricula and have already refined the implementation of modern IDE debuggers.},
booktitle = {Proceedings of the 40th International Conference on Software Engineering},
pages = {572–583},
numpages = {12},
location = {Gothenburg, Sweden},
series = {ICSE '18}
}

@misc{DebugSkew,
      title={An Exploratory Study of Debugging Episodes}, 
      author={Abdulaziz Alaboudi and Thomas D. LaToza},
      year={2021},
      eprint={2105.02162},
      archivePrefix={arXiv},
      primaryClass={cs.SE},
      url={https://arxiv.org/abs/2105.02162}, 
}

@article{StudentTypeErrorFixes,
author = {Wu, Baijun and Chen, Sheng},
title = {How type errors were fixed and what students did?},
year = {2017},
issue_date = {October 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {OOPSLA},
url = {https://doi.org/10.1145/3133929},
doi = {10.1145/3133929},
abstract = {Providing better supports for debugging type errors has been an active research area in the last three decades. Numerous approaches from different perspectives have been developed. Most approaches work well under certain conditions only, for example, when type errors are caused by single leaves and when type annotations are correct. However, the research community is still unaware of which conditions hold in practice and what the real debugging situations look like. We address this problem with a study of 3 program data sets, which were written in different years, using different compilers, and were of diverse sizes. They include more than 55,000 programs, among which more than 2,700 are ill typed. We investigated all the ill-typed programs, and our results indicate that current error debugging support is far from sufficient in practice since only about 35\% of all type errors were caused by single leaves. In addition, type annotations cannot always be trusted in error debuggers since about 30\% of the time type errors were caused by wrong type annotations. Our study also provides many insights about the debugging behaviors of students in functional programming, which could be exploited for developing more effective error debuggers.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {105},
numpages = {27},
keywords = {type inference, empirical study, Type-error debugging}
}

@INPROCEEDINGS{HowFixBugs,
  author={Coker, Zack and Widder, David Gray and Le Goues, Claire and Bogart, Christopher and Sunshine, Joshua},
  booktitle={2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)}, 
  title={A Qualitative Study on Framework Debugging}, 
  year={2019},
  volume={},
  number={},
  pages={568-579},
  keywords={Debugging;Task analysis;Androids;Humanoid robots;Encoding;Protocols;Frameworks;Debugging;Qualitative study},
  doi={10.1109/ICSME.2019.00091}}

@INPROCEEDINGS{DebugNeeds,
  author={Layman, Lucas and Diep, Madeline and Nagappan, Meiyappan and Singer, Janice and Deline, Robert and Venolia, Gina},
  booktitle={2013 ACM / IEEE International Symposium on Empirical Software Engineering and Measurement}, 
  title={Debugging Revisited: Toward Understanding the Debugging Needs of Contemporary Software Developers}, 
  year={2013},
  volume={},
  number={},
  pages={383-392},
  keywords={Debugging;Interviews;Encoding;Computer bugs;Web services;Testing;debugging;software engineering;interview;professionals;qualitative analysis;program comprehension},
  doi={10.1109/ESEM.2013.43}}

@phdthesis{LogicProg,
  title={Applied logic: its use and implementation as a programming tool},
  author={Warren, David HD},
  year={1978},
  school={The University of Edinburgh}
}

@article{ModeCorrectness,
  title={Adding redundancy to obtain more reliable and more readable prolog programs},
  author={Bruynooghe, Maurice},
  journal={CW Reports},
  pages={5--5},
  year={1982},
  publisher={Department of Computer Science, KU Leuven, Leuven, Belgium}
}
@book{ATTAPL,
  title={Advanced topics in types and programming languages},
  author={Pierce, Benjamin C},
  year={2024},
  publisher={MIT press}
}



@article{SystemFUndecidable,
title = {Typability and type checking in System F are equivalent and undecidable},
journal = {Annals of Pure and Applied Logic},
volume = {98},
number = {1},
pages = {111-156},
year = {1999},
issn = {0168-0072},
doi = {https://doi.org/10.1016/S0168-0072(98)00047-5},
url = {https://www.sciencedirect.com/science/article/pii/S0168007298000475},
author = {J.B. Wells},
keywords = {System F, Semi-unification, Type inference, Typability, Type checking, Lambda calculus},
abstract = {Girard and Reynolds independently invented System F (a.k.a. the second-order polymorphically typed lambda calculus) to handle problems in logic and computer programming language design, respectively. Viewing F in the Curry style, which associates types with untyped lambda terms, raises the questions of typability and type checking. Typability asks for a term whether there exists some type it can be given. Type checking asks, for a particular term and type, whether the term can be given that type. The decidability of these problems has been settled for restrictions and extensions of F and related systems and complexity lower-bounds have been determined for typability in F, but this report is the first to resolve whether these problems are decidable for System F. This report proves that type checking in F is undecidable, by a reduction from semi-unification, and that typability in F is undecidable, by a reduction from type checking. Because there is an easy reduction from typability to type checking, the two problems are equivalent. The reduction from type checking to typability uses a novel method of constructing lambda terms that simulate arbitrarily chosen type environments. All of the results also hold for the λI-calculus.}
}

@ARTICLE{TraceVisualisation,
  author={Cornelissen, Bas and Zaidman, Andy and van Deursen, Arie},
  journal={IEEE Transactions on Software Engineering}, 
  title={A Controlled Experiment for Program Comprehension through Trace Visualization}, 
  year={2011},
  volume={37},
  number={3},
  pages={341-355},
  keywords={Visualization;Computer Society;Time measurement;Programming;Documentation;Scalability;Software maintenance;Gain measurement;Control systems;Performance evaluation;Program comprehension;dynamic analysis;controlled experiment.},
  doi={10.1109/TSE.2010.47}}

  @ARTICLE{DynamicLangShift,
  author={Paulson, Linda Dailey},
  journal={Computer}, 
  title={Developers shift to dynamic programming languages}, 
  year={2007},
  volume={40},
  number={2},
  pages={12-15},
  keywords={Dynamic programming;Java;Runtime;Programming profession;Application software;Computer languages;Error correction;Testing;Mission critical systems;Memory management;dynamic programming languages;PHP;Perl;Ruby},
  doi={10.1109/MC.2007.53}}

@online{TIOBE,
  author       = {TIOBE Software},
  title        = {TIOBE Programming Community Index},
  year         = 2025,
  url          = {https://www.tiobe.com/tiobe-index/},
  urldate = {2025-02-27}
}

@inproceedings{DynamicTyping,
author = {Abadi, M. and Cardelli, L. and Pierce, B. and Plotkin, G.},
title = {Dynamic typing in a statically-typed language},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75296},
doi = {10.1145/75277.75296},
abstract = {Statically-typed programming languages allow earlier error checking, better enforcement of disciplined programming styles, and generation of more efficient object code than languages where all type-consistency checks are performed at runtime. However, even in statically-type languages, there is often the need to deal with data whose type cannot be known at compile time. To handle such situations safely, we propose to add a type Dynamic whose values are pairs of a value v and a type tag T where v has the type denoted by T. Instances of Dynamic are built with an explicit tagging construct and inspected with a type-safe typecase construct.This paper is an exploration of the syntax, operational semantics, and denotational semantics of a simple language with the type Dynamic. We give examples of how dynamically-typed values might be used in programming. Then we discuss an operational semantics for our language and obtain a soundness theorem. We present two formulations of the denotational semantics of this language and relate them to the operational semantics. Finally, we consider the implications of polymorphism and some implementation issues.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {213–227},
numpages = {15},
location = {Austin, Texas, USA},
series = {POPL '89}
}

@inproceedings{SemanticCasts,
  title={Semantic casts: Contracts and structural subtyping in a nominal world},
  author={Findler, Robert Bruce and Flatt, Matthew and Felleisen, Matthias},
  booktitle={European Conference on Object-Oriented Programming},
  pages={365--389},
  year={2004},
  organization={Springer}
}


@inproceedings{Contracts,
author = {Findler, Robert Bruce and Felleisen, Matthias},
title = {Contracts for higher-order functions},
year = {2002},
isbn = {1581134878},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/581478.581484},
doi = {10.1145/581478.581484},
abstract = {Assertions play an important role in the construction of robust software. Their use in programming languages dates back to the 1970s. Eiffel, an object-oriented programming language, wholeheartedly adopted assertions and developed the "Design by Contract" philosophy. Indeed, the entire object-oriented community recognizes the value of assertion-based contracts on methods.In contrast, languages with higher-order functions do not support assertion-based contracts. Because predicates on functions are, in general, undecidable, specifying such predicates appears to be meaningless. Instead, the functional languages community developed type systems that statically approximate interesting predicates.In this paper, we show how to support higher-order function contracts in a theoretically well-founded and practically viable manner. Specifically, we introduce λcon, a typed lambda calculus with assertions for higher-order functions. The calculus models the assertion monitoring system that we employ in DrScheme. We establish basic properties of the model (type soundness, etc.) and illustrate the usefulness of contract checking with examples from DrScheme's code base.We believe that the development of an assertion system for higher-order functions serves two purposes. On one hand, the system has strong practical potential because existing type systems simply cannot express many assertions that programmers would like to state. On the other hand, an inspection of a large base of invariants may provide inspiration for the direction of practical future type system research.},
booktitle = {Proceedings of the Seventh ACM SIGPLAN International Conference on Functional Programming},
pages = {48–59},
numpages = {12},
keywords = {solfware reliability, predicate typing, higher-order functions, contracts, behavioral specifications},
location = {Pittsburgh, PA, USA},
series = {ICFP '02}
}

  


@book{BasicCatTheory,
  title={Basic category theory for computer scientists},
  author={Pierce, Benjamin C},
  year={1991},
  publisher={MIT press}
}

@article{OneHoleContext,
  title={The derivative of a regular type is its type of one-hole contexts},
  author={McBride, Conor},
  journal={Unpublished manuscript},
  pages={74--88},
  year={2001}
}

@article{TypeDerivatives,
author = {McBride, Conor},
title = {Clowns to the left of me, jokers to the right (pearl): dissecting data structures},
year = {2008},
issue_date = {January 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1328897.1328474},
doi = {10.1145/1328897.1328474},
abstract = {This paper introduces a small but useful generalisation to the 'derivative' operation on datatypes underlying Huet's notion of 'zipper', giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, 'dissection', turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right.I present dissection here as a generic program, albeit for polynomial functors only. The notion is certainly applicable more widely, but here I prefer to concentrate on its diverse applications. For a start, map-like operations over the functor and fold-like operations over the recursive data structure it induces can be expressed by tail recursion alone. Further, the derivative is readily recovered from the dissection. Indeed, it is the dissection structure which delivers Huet's operations for navigating zippers.The original motivation for dissection was to define 'division', capturing the notion of leftmost hole, canonically distinguishing values with no elements from those with at least one. Division gives rise to an isomorphism corresponding to the remainder theorem in algebra. By way of a larger example, division and dissection are exploited to give a relatively efficient generic algorithm for abstracting all occurrences of one term from another in a first-order syntax. The source code for the paper is available online and compiles with recent extensions to the Glasgow Haskell Compiler.},
journal = {SIGPLAN Not.},
month = jan,
pages = {287–295},
numpages = {9},
keywords = {datatype, differentiation, dissection, division, generic programming, iteration, polynomial, stack, tail recursion, traversal, zipper}
}



@book{RealWorldOCaml,
  title={Real World OCaml: Functional programming for the masses},
  author={Minsky, Yaron and Madhavapeddy, Anil and Hickey, Jason},
  year={2013},
  publisher={O'Reilly Media, Inc.}
}

@techreport{PolymorphicVariants,
  title={A polymorphic type system for extensible records and variants},
  author={Gaster, Benedict R and Jones, Mark P},
  year={1996},
  institution={Technical Report NOTTCS-TR-96-3, Department of Computer Science, University of Nottingham}
}

@inproceedings{StructuralSubtyping,
  title={Structural subtyping and the notion of power type},
  author={Cardelli, Luca},
  booktitle={Proceedings of the 15th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={70--79},
  year={1988}
}

@article{LivePatternMatching,
author = {Yuan, Yongwei and Guest, Scott and Griffis, Eric and Potter, Hannah and Moon, David and Omar, Cyrus},
title = {Live Pattern Matching with Typed Holes},
year = {2023},
issue_date = {April 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3586048},
doi = {10.1145/3586048},
abstract = {Several modern programming systems, including GHC Haskell, Agda, Idris, and Hazel, support typed holes. Assigning static and, to varying degree, dynamic meaning to programs with holes allows program editors and other tools to offer meaningful feedback and assistance throughout editing, i.e. in a live manner. Prior work, however, has considered only holes appearing in expressions and types. This paper considers, from type theoretic and logical first principles, the problem of typed pattern holes. We confront two main difficulties, (1) statically reasoning about exhaustiveness and irredundancy when patterns are not fully known, and (2) live evaluation of expressions containing both pattern and expression holes. In both cases, this requires reasoning conservatively about all possible hole fillings. We develop a typed lambda calculus, Peanut, where reasoning about exhaustiveness and redundancy is mapped to the problem of deriving first order entailments. We equip Peanut with an operational semantics in the style of Hazelnut Live that allows us to evaluate around holes in both expressions and patterns. We mechanize the metatheory of Peanut in Agda and formalize a procedure capable of deciding the necessary entailments. Finally, we scale up and implement these mechanisms within Hazel, a programming environment for a dialect of Elm that automatically inserts holes during editing to provide static and dynamic feedback to the programmer in a maximally live manner, i.e. for every possible editor state. Hazel is the first maximally live environment for a general-purpose functional language.},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {96},
numpages = {27},
keywords = {typed holes, pattern matching}
}

@book{PracticalFoundationsEd1, place={Cambridge}, title={Practical Foundations for Programming Languages}, publisher={Cambridge University Press}, author={Harper, Robert}, year={2012}}

@article{NondeterministicAlgorithms,
author = {Floyd, Robert W.},
title = {Nondeterministic Algorithms},
year = {1967},
issue_date = {Oct. 1967},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {4},
issn = {0004-5411},
url = {https://doi.org/10.1145/321420.321422},
doi = {10.1145/321420.321422},
abstract = {Programs to solve combinatorial search problems may often be simply written by using multiple-valued functions. Such programs, although impossible to execute directly on conventional computers, may be converted in a mechanical way into conventional backtracking programs. The process is illustrated with algorithms to find all solutions to the eight queens problem on the chessboard, and to find all simple cycles in a network.},
journal = {J. ACM},
month = oct,
pages = {636–644},
numpages = {9}
}

@article{NondetDSL,
   title={Effects Without Monads: Non-determinism – Back to the Meta Language},
   volume={294},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.294.2},
   DOI={10.4204/eptcs.294.2},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Kiselyov, Oleg},
   year={2019},
   month=may, pages={15–40} }
   
   @Inbook{TaglessFinalDSL,
author="Kiselyov, Oleg",
editor="Gibbons, Jeremy",
title="Typed Tagless Final Interpreters",
bookTitle="Generic and Indexed Programming: International Spring School, SSGIP 2010, Oxford, UK, March 22-26, 2010, Revised Lectures",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="130--174",
abstract="The so-called `typed tagless final' approach of [6] has collected and polished a number of techniques for representing typed higher-order languages in a typed metalanguage, along with type-preserving interpretation, compilation and partial evaluation. The approach is an alternative to the traditional, or `initial' encoding of an object language as a (generalized) algebraic data type. Both approaches permit multiple interpretations of an expression, to evaluate it, pretty-print, etc. The final encoding represents all and only typed object terms without resorting to generalized algebraic data types, dependent or other fancy types. The final encoding lets us add new language forms and interpretations without breaking the existing terms and interpreters.",
isbn="978-3-642-32202-0",
doi="10.1007/978-3-642-32202-0_3",
url="https://doi.org/10.1007/978-3-642-32202-0_3"
}


@inproceedings{Bunches,
author = {Spivey, Michael},
year = {2006},
month = {07},
pages = {},
title = {Algebras for Combinatorial Search},
doi = {10.14236/ewic/MSFP2006.11}
}

@InProceedings{ListOfSuccess,
author="Wadler, Philip",
editor="Jouannaud, Jean-Pierre",
title="How to replace failure by a list of successes a method for exception handling, backtracking, and pattern matching in lazy functional languages",
booktitle="Functional Programming Languages and Computer Architecture",
year="1985",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="113--128",
abstract="Should special features for exception handling, backtracking, or pattern matching be included in a programming language? This paper presents a method whereby some programs that use these features can be re-written in a functional language with lazy evaluation, without the use of any special features. This method may be of use for practicing functional programmers; in addition, it provides further evidence of the power of lazy evaluation. The method itself is straightforward: each term that may raise an exception or backtrack is replaced by a term that returns a list of values. In the special case of pattern matching without backtracking, the method can be applied even if lazy evaluation is not present. The method should be suitable for applications such as theorem proving using tacticals, as in ML/LCF.",
isbn="978-3-540-39677-2"
}

@article{BFSCombinators,
author = {Spivey, Michael},
title = {Combinators for breadth-first search},
year = {2000},
issue_date = {July 2000},
publisher = {Cambridge University Press},
address = {USA},
volume = {10},
number = {4},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796800003749},
doi = {10.1017/S0956796800003749},
journal = {J. Funct. Program.},
month = jul,
pages = {397–408},
numpages = {12}
}

@book{NorvigAI,
  title={Artificial intelligence: a modern approach},
  author={Russell, Stuart J and Norvig, Peter},
  year={2016},
  publisher={pearson}
}

@article{NeededNarrowing,
author = {Antoy, Sergio and Echahed, Rachid and Hanus, Michael},
title = {A needed narrowing strategy},
year = {2000},
issue_date = {July 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {4},
issn = {0004-5411},
url = {https://doi.org/10.1145/347476.347484},
doi = {10.1145/347476.347484},
abstract = {The narrowing relation over terms constitutes the basis of the most important operational semantics of languages that integrate functional and logic programming paradigms. It also plays an important role in the definition of some algorithms of unification modulo equational theories that are defined by confluent term rewriting systems. Due to the inefficiency of simple narrowing, many refined narrowing strategies have been proposed in the last decade. This paper presents a new narrowing strategy that is optimal in several respects. For this purpose, we propose a notion of a needed narrowing step that, for inductively sequential rewrite systems, extends the Huet and L\'{e}vy notion of a needed reduction step. We define a strategy, based on this notion, that computes only needed  narrowing steps. Our strategy is sound and complete for a large class of rewrite systems, is optimal with respect to the cost measure that counts the number of distinct steps of a derivation, computes only incomparable and disjoint unifiers, and is efficiently implemented by unification.},
journal = {J. ACM},
month = jul,
pages = {776–822},
numpages = {47},
keywords = {rewrite systems, narrowing strategies, functional logic programming languages, call-by-need}
}

@article{FunctionalLogicProgramming,
author = {Antoy, Sergio and Hanus, Michael},
title = {Functional logic programming},
year = {2010},
issue_date = {April 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {53},
number = {4},
issn = {0001-0782},
url = {https://doi.org/10.1145/1721654.1721675},
doi = {10.1145/1721654.1721675},
abstract = {Combining the paradigm features of both logic and functional programming makes for some powerful implementations.},
journal = {Commun. ACM},
month = apr,
pages = {74–85},
numpages = {12}
}

@article{UnificationSurvey,
  title={Unification: A multidisciplinary survey},
  author={Knight, Kevin},
  journal={ACM Computing Surveys (CSUR)},
  volume={21},
  number={1},
  pages={93--124},
  year={1989},
  publisher={ACM New York, NY, USA}
}

@inproceedings{NeuralGuidedLogicProgramSynthesis,
 author = {Zhang, Lisa and Rosenblatt, Gregory and Fetaya, Ethan and Liao, Renjie and Byrd, William and Might, Matthew and Urtasun, Raquel and Zemel, Richard},
 booktitle = {Advances in Neural Information Processing Systems},
 editor = {S. Bengio and H. Wallach and H. Larochelle and K. Grauman and N. Cesa-Bianchi and R. Garnett},
 pages = {},
 publisher = {Curran Associates, Inc.},
 title = {Neural Guided Constraint Logic Programming for Program Synthesis},
 url = {https://proceedings.neurips.cc/paper_files/paper/2018/file/67d16d00201083a2b118dd5128dd6f59-Paper.pdf},
 volume = {31},
 year = {2018}
}

@INPROCEEDINGS{LogicProgramSynthesisDrawbacks,
  author={Kodratoff, Y. and Franova, M. and Partridge, D.},
  booktitle={Systems Integration '90. Proceedings of the First International Conference on Systems Integration}, 
  title={Logic programming and program synthesis}, 
  year={1990},
  volume={},
  number={},
  pages={346-355},
  keywords={Logic programming;Artificial intelligence;Automatic logic units;Formal specifications;Certification;Software engineering;Application software;Automatic control;Control systems;Reflection},
  doi={10.1109/ICSI.1990.138700}}

@inproceedings{ProgramSynthesisSketching,
author = {Solar-Lezama, Armando},
title = {The Sketching Approach to Program Synthesis},
year = {2009},
isbn = {9783642106712},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-10672-9_3},
doi = {10.1007/978-3-642-10672-9_3},
abstract = {Sketching is a new form of localized software synthesis that aims to bridge the gap between a programmer's high-level insights about a problem and the computer's ability to manage low-level details. In sketching, the programmer uses partial programs to describe the desired implementation <em>strategy</em> , and leaves the low-level details of the implementation to an automated synthesis procedure. This paper describes the sketching approach to program synthesis, including the details of the <Emphasis Type="SmallCaps">Sketch</Emphasis> language and synthesizer. The paper will then describe some of the techniques that make synthesis from sketches possible, and will close with a brief discussion of open problems in programmer guided synthesis.},
booktitle = {Proceedings of the 7th Asian Symposium on Programming Languages and Systems},
pages = {4–13},
numpages = {10},
location = {Seoul, Korea},
series = {APLAS '09}
}

@article{SMTs,
author = {De Moura, Leonardo and Bj\o{}rner, Nikolaj},
title = {Satisfiability modulo theories: introduction and applications},
year = {2011},
issue_date = {September 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {54},
number = {9},
issn = {0001-0782},
url = {https://doi.org/10.1145/1995376.1995394},
doi = {10.1145/1995376.1995394},
abstract = {Checking the satisfiability of logical formulas, SMT solvers scale orders of magnitude beyond custom ad hoc solvers.},
journal = {Commun. ACM},
month = sep,
pages = {69–77},
numpages = {9}
}

@inproceedings{SMTSolver,
  title={Z3: An efficient SMT solver},
  author={De Moura, Leonardo and Bj{\o}rner, Nikolaj},
  booktitle={International conference on Tools and Algorithms for the Construction and Analysis of Systems},
  pages={337--340},
  year={2008},
  organization={Springer}
}

@inproceedings{PolymorphicSMTs,
author = {Bobot, Fran\c{c}ois and Conchon, Sylvain and Contejean, Evelyne and Lescuyer, St\'{e}phane},
title = {Implementing polymorphism in SMT solvers},
year = {2008},
isbn = {9781605584409},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1512464.1512466},
doi = {10.1145/1512464.1512466},
abstract = {Based on our experience with the development of Alt-Ergo, we show the small number of modifications needed to bring parametric polymorphism to our SMT solver. The first one occurs in the typing module where unification is now necessary for solving polymorphic constraints over types. The second one consists in extending triggers' definition in order to deal with both term and type variables. Last, the matching module must be modified to account for the instantiation of type variables. We hope that this experience is convincing enough to raise interest for polymorphism in the SMT community.},
booktitle = {Proceedings of the Joint Workshops of the 6th International Workshop on Satisfiability Modulo Theories and 1st International Workshop on Bit-Precise Reasoning},
pages = {1–5},
numpages = {5},
location = {Princeton, New Jersey, USA},
series = {SMT '08/BPR '08}
}

@inproceedings{PrincipleTypeSchemes,
author = {Damas, Luis and Milner, Robin},
title = {Principal type-schemes for functional programs},
year = {1982},
isbn = {0897910656},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/582153.582176},
doi = {10.1145/582153.582176},
booktitle = {Proceedings of the 9th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {207–212},
numpages = {6},
location = {Albuquerque, New Mexico},
series = {POPL '82}
}

@InProceedings{PrologDelimControl,
author="Vandenbroucke, Alexander
and Schrijvers, Tom",
editor="De Angelis, Emanuele
and Vanhoof, Wim",
title="Disjunctive Delimited Control",
booktitle="Logic-Based Program Synthesis and Transformation",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="75--91",
abstract="Delimited control is a powerful mechanism for programming language extension which has been recently proposed for Prolog (and implemented in SWI-Prolog). By manipulating the control flow of a program from inside the language, it enables the implementation of powerful features, such as tabling, without modifying the internals of the Prolog engine. However, its current formulation is inadequate: it does not capture Prolog's unique non-deterministic nature which allows multiple ways to satisfy a goal.",
isbn="978-3-030-98869-2"
}

@article{PartialOrder,
  title={Partially ordered sets},
  author={MacNeille, Holbrook Mann},
  journal={Transactions of the American Mathematical Society},
  volume={42},
  number={3},
  pages={416--460},
  year={1937}
}


@misc{OCamlCorpus,
  author       = {Eric L Seidel and Ranjit Jhala},
  title        = {A Collection of Novice Interactions with the {OCaml} {Top-Level} System},
  month        = jun,
  year         = 2017,
  doi          = {10.5281/zenodo.806814},
  url          = {https://doi.org/10.5281/zenodo.806814}
}

@misc{HazelOfOCaml,
  author       = {Patrick Ferris},
  title        = {OCaml to Hazel transpiler},
  month        = may,
  year         = 2025,
  url          = {https://github.com/patricoferris/hazel_of_ocaml}
}

@misc{HazelCorpus,
  author       = {Patrick Ferris},
  title        = {A Corpus of annotated and unannotated ill-typed Hazel Programs},
  month        = may,
  year         = 2025,
  url          = {https://github.com/patricoferris/hazel-corpus}
}

@book{SmallScopeHypothesisOrigination,
author = {Jackson, Daniel},
title = {Software Abstractions: Logic, Language, and Analysis},
year = {2012},
isbn = {0262017156},
publisher = {The MIT Press},
abstract = {In Software Abstractions Daniel Jackson introduces an approach to software design that draws on traditional formal methods but exploits automated tools to find flaws as early as possible. This approach--which Jackson calls "lightweight formal methods" or "agile modeling"--takes from formal specification the idea of a precise and expressive notation based on a tiny core of simple and robust concepts but replaces conventional analysis based on theorem proving with a fully automated analysis that gives designers immediate feedback. Jackson has developed Alloy, a language that captures the essence of software abstractions simply and succinctly, using a minimal toolkit of mathematical notions. This revised edition updates the text, examples, and appendixes to be fully compatible with the latest version of Alloy (Alloy 4). The designer can use automated analysis not only to correct errors but also to make models that are more precise and elegant. This approach, Jackson says, can rescue designers from "the tarpit of implementation technologies" and return them to thinking deeply about underlying concepts. Software Abstractions introduces the key elements: a logic, which provides the building blocks of the language; a language, which adds a small amount of syntax to the logic for structuring descriptions; and an analysis, a form of constraint solving that offers both simulation (generating sample states and executions) and checking (finding counterexamples to claimed properties).}
}

@article{EagerCasts,
author = {Henglein, Fritz},
title = {Dynamic typing: syntax and proof theory},
year = {1994},
issue_date = {June 1994},
publisher = {Elsevier North-Holland, Inc.},
address = {USA},
volume = {22},
number = {3},
issn = {0167-6423},
url = {https://doi.org/10.1016/0167-6423(94)00004-2},
doi = {10.1016/0167-6423(94)00004-2},
journal = {Sci. Comput. Program.},
month = jun,
pages = {197–230},
numpages = {34}
}

@ARTICLE{GradualEagerCasts,
  title     = "Space-efficient gradual typing",
  author    = "Herman, David and Tomb, Aaron and Flanagan, Cormac",
  journal   = "High.-order Symb. Comput.",
  publisher = "Springer Science and Business Media LLC",
  volume    =  23,
  number    =  2,
  pages     = "167--189",
  month     =  jun,
  year      =  2010,
  language  = "en"
}

@article{SymbolicExecutionSurvey,
author = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
title = {A Survey of Symbolic Execution Techniques},
year = {2018},
issue_date = {May 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {3},
issn = {0360-0300},
url = {https://doi.org/10.1145/3182657},
doi = {10.1145/3182657},
abstract = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program’s authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
journal = {ACM Comput. Surv.},
month = may,
articleno = {50},
numpages = {39},
keywords = {static analysis, software testing, concolic execution, Symbolic execution}
}

@inproceedings{10.1145/1291151.1291159,
author = {Syme, Don and Neverov, Gregory and Margetson, James},
title = {Extensible pattern matching via a lightweight language extension},
year = {2007},
isbn = {9781595938152},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1291151.1291159},
doi = {10.1145/1291151.1291159},
abstract = {Pattern matching of algebraic data types (ADTs) is a standard feature in typed functional programming languages, but it is well known that it interacts poorly with abstraction. While several partial solutions to this problem have been proposed, few have been implemented or used. This paper describes an extension to the .NET language F# called active patterns, which supports pattern matching over abstract representations of generic heterogeneous data such as XML and term structures, including where these are represented via object models in other .NET languages. Our design is the first to incorporate both ad hoc pattern matching functions for partial decompositions and "views" for total decompositions, and yet remains a simple and lightweight extension. We give a description of the language extension along with numerous motivating examples. Finally we describe how this feature would interact with other reasonable and related language extensions: existential types quantified at data discrimination tags, GADTs, and monadic generalizations of pattern matching.},
booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming},
pages = {29–40},
numpages = {12},
keywords = {F#, ML, functional programming, pattern matching},
location = {Freiburg, Germany},
series = {ICFP '07}
}

@article{ActivePatterns,
author = {Syme, Don and Neverov, Gregory and Margetson, James},
title = {Extensible pattern matching via a lightweight language extension},
year = {2007},
issue_date = {September 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1291220.1291159},
doi = {10.1145/1291220.1291159},
abstract = {Pattern matching of algebraic data types (ADTs) is a standard feature in typed functional programming languages, but it is well known that it interacts poorly with abstraction. While several partial solutions to this problem have been proposed, few have been implemented or used. This paper describes an extension to the .NET language F# called active patterns, which supports pattern matching over abstract representations of generic heterogeneous data such as XML and term structures, including where these are represented via object models in other .NET languages. Our design is the first to incorporate both ad hoc pattern matching functions for partial decompositions and "views" for total decompositions, and yet remains a simple and lightweight extension. We give a description of the language extension along with numerous motivating examples. Finally we describe how this feature would interact with other reasonable and related language extensions: existential types quantified at data discrimination tags, GADTs, and monadic generalizations of pattern matching.},
journal = {SIGPLAN Not.},
month = oct,
pages = {29–40},
numpages = {12},
keywords = {F#, ML, functional programming, pattern matching}
}

@inproceedings{Views,
author = {Wadler, P.},
title = {Views: a way for pattern matching to cohabit with data abstraction},
year = {1987},
isbn = {0897912152},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/41625.41653},
doi = {10.1145/41625.41653},
abstract = {Pattern matching and data abstraction are important concepts in designing programs, but they do not fit well together. Pattern matching depends on making public a free data type representation, while data abstraction depends on hiding the representation. This paper proposes the views mechanism as a means of reconciling this conflict. A view allows any type to be viewed as a free data type, thus combining the clarity of pattern matching with the efficiency of data abstraction.},
booktitle = {Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {307–313},
numpages = {7},
location = {Munich, West Germany},
series = {POPL '87}
}

@article{PatternMatchingWarnings, title={Warnings for pattern matching}, volume={17}, DOI={10.1017/S0956796807006223}, number={3}, journal={Journal of Functional Programming}, author={MARANGET, LUC}, year={2007}, pages={387–421}} <div></div>