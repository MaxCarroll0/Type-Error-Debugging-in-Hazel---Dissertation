@inproceedings{SearchProc,
  series = {ICFP’16},
  title = {Dynamic witnesses for static type errors (or,  ill-typed programs usually go wrong)},
  url = {http://dx.doi.org/10.1145/2951913.2951915},
  DOI = {10.1145/2951913.2951915},
  booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
  publisher = {ACM},
  author = {Seidel,  Eric L. and Jhala,  Ranjit and Weimer,  Westley},
  year = {2016},
  month = sep,
  pages = {228–242},
  collection = {ICFP’16}
}

@online{Hazel,
title = {Hazel Project Website},
url = {https://hazel.org/},
urldate = {2025-02-28},
}

@online{EffectsExamples,
title = {OCaml Effects Examples},
url = {https://github.com/ocaml-multicore/effects-examples/tree/master},
urldate = {2025-03-26}
}

@article{10.1145/2544174.2500590,
author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
title = {Handlers in action},
year = {2013},
issue_date = {September 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2544174.2500590},
doi = {10.1145/2544174.2500590},
abstract = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
journal = {SIGPLAN Not.},
month = sep,
pages = {145–158},
numpages = {14},
keywords = {algebraic effects, continuations, effect handlers, effect typing, haskell, modularity, monads}
}

@inproceedings{HandlersInAction,
author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
title = {Handlers in action},
year = {2013},
isbn = {9781450323260},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2500365.2500590},
doi = {10.1145/2500365.2500590},
abstract = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
pages = {145–158},
numpages = {14},
keywords = {algebraic effects, continuations, effect handlers, effect typing, haskell, modularity, monads},
location = {Boston, Massachusetts, USA},
series = {ICFP '13}
}


@manual{OCamlManual,
  title        = {The OCaml Manual: release 5.2},
  author       = {The OCaml Development Team},
  year         = {2024},
  url          = {https://ocaml.org/manual/5.2/index.html},
  note         = {Accessed: 2025-02-28}
}
@online{HazelCode,
title = {Hazel Source Code},
url = {https://github.com/hazelgrove/hazel},
urldate = {2025-02-28},
}

@online{ConcurrentZipper,
title = {Generic Zippers},
url = {https://okmij.org/ftp/continuations/zipper.html},
author = {Oleg Kiselyov}
}

@online{MultiZipper,
title = {Multi Zippers},
url = {https://pavpanchekha.com/blog/zippers/multi-zippers.html#org1556357},
author = {Pavel Panchekha}
}

@online{DelimitedControl,
title = {Delimited Control in OCaml},
url = {https://okmij.org/ftp/continuations/implementations.html},
author = {Oleg Kiselyov}
}

@inbook{Blame,
  title = {Well-Typed Programs Can’t Be Blamed},
  ISBN = {9783642005909},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-642-00590-9_1},
  DOI = {10.1007/978-3-642-00590-9_1},
  booktitle = {Programming Languages and Systems},
  publisher = {Springer Berlin Heidelberg},
  author = {Wadler,  Philip and Findler,  Robert Bruce},
  year = {2009},
  pages = {1–16}
}

@article{ErrSlice,
  title = {A slicing-based approach for locating type errors},
  volume = {10},
  ISSN = {1557-7392},
  url = {http://dx.doi.org/10.1145/366378.366379},
  DOI = {10.1145/366378.366379},
  number = {1},
  journal = {ACM Transactions on Software Engineering and Methodology},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Tip,  F. and Dinesh,  T. B.},
  year = {2001},
  month = jan,
  pages = {5–55}
}

@article{HaackErrSlice,
  title = {Type error slicing in implicitly typed higher-order languages},
  volume = {50},
  ISSN = {0167-6423},
  url = {http://dx.doi.org/10.1016/j.scico.2004.01.004},
  DOI = {10.1016/j.scico.2004.01.004},
  number = {1–3},
  journal = {Science of Computer Programming},
  publisher = {Elsevier BV},
  author = {Haack,  Christian and Wells,  J.B.},
  year = {2004},
  month = mar,
  pages = {189–224}
}

@inbook{ConstraintFreeErrSlice,
  title = {Constraint-Free Type Error Slicing},
  ISBN = {9783642320378},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-642-32037-8_1},
  DOI = {10.1007/978-3-642-32037-8_1},
  booktitle = {Trends in Functional Programming},
  publisher = {Springer Berlin Heidelberg},
  author = {Schilling,  Thomas},
  year = {2012},
  pages = {1–16}
}

@article{DynProgSlice,
  title = {Dynamic program slicing},
  volume = {29},
  ISSN = {0020-0190},
  url = {http://dx.doi.org/10.1016/0020-0190(88)90054-3},
  DOI = {10.1016/0020-0190(88)90054-3},
  number = {3},
  journal = {Information Processing Letters},
  publisher = {Elsevier BV},
  author = {Korel,  Bogdan and Laski,  Janusz},
  year = {1988},
  month = oct,
  pages = {155–163}
}
@article{ProgSlice,
  doi = {10.7302/11363},
  url = {http://deepblue.lib.umich.edu/handle/2027.42/180974},
  author = {Weiser,  Mark David},
  title = {Program Slices: Formal,  Psychological,  And Practical Investigations Of An Automatic Program Abstraction Method.},
  publisher = {My University},
  year = {1979}
}

@article{HazelLivePaper,
  title = {Live functional programming with typed holes},
  volume = {3},
  ISSN = {2475-1421},
  url = {http://dx.doi.org/10.1145/3290327},
  DOI = {10.1145/3290327},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Omar,  Cyrus and Voysey,  Ian and Chugh,  Ravi and Hammer,  Matthew A.},
  year = {2019},
  month = jan,
  pages = {1–32}
}

@inbook{StandardMLTypeTheory,
  title = {A Type-Theoretic Interpretation of Standard ML},
  ISBN = {9780262281676},
  url = {http://dx.doi.org/10.7551/mitpress/5641.003.0019},
  DOI = {10.7551/mitpress/5641.003.0019},
  booktitle = {Proof,  Language,  and Interaction},
  publisher = {The MIT Press},
  author = {Harper,  Robert and Stone,  Christopher},
  year = {2000},
  month = may,
  pages = {341–388}
}

@article{CoreXML,
  title = {On the type structure of standard ML},
  volume = {15},
  ISSN = {1558-4593},
  url = {http://dx.doi.org/10.1145/169701.169696},
  DOI = {10.1145/169701.169696},
  number = {2},
  journal = {ACM Transactions on Programming Languages and Systems},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Harper,  Robert and Mitchell,  John C.},
  year = {1993},
  month = apr,
  pages = {211–252}
}

@article{LocalInference,
  title = {Local type inference},
  volume = {22},
  ISSN = {1558-4593},
  url = {http://dx.doi.org/10.1145/345099.345100},
  DOI = {10.1145/345099.345100},
  number = {1},
  journal = {ACM Transactions on Programming Languages and Systems},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Pierce,  Benjamin C. and Turner,  David N.},
  year = {2000},
  month = jan,
  pages = {1–44}
}

@inproceedings{BidirectionalTypes,
  series = {ICFP’13},
  title = {Complete and easy bidirectional typechecking for higher-rank polymorphism},
  url = {http://dx.doi.org/10.1145/2500365.2500582},
  DOI = {10.1145/2500365.2500582},
  booktitle = {Proceedings of the 18th ACM SIGPLAN international conference on Functional programming},
  publisher = {ACM},
  author = {Dunfield,  Jana and Krishnaswami,  Neelakantan R.},
  year = {2013},
  month = sep,
  collection = {ICFP’13}
}

@inbook{GradualObjects,
  title = {Gradual Typing for Objects},
  ISBN = {9783540735892},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-540-73589-2_2},
  DOI = {10.1007/978-3-540-73589-2_2},
  booktitle = {ECOOP 2007 – Object-Oriented Programming},
  publisher = {Springer Berlin Heidelberg},
  author = {Siek,  Jeremy and Taha,  Walid},
  year = {2007},
  pages = {2–27}
}

@inbook{GradualFunctional,
  title = {Gradual Typing for Functional Languages},
  author = {Jeremy G. Siek and Walid Taha},
  booktitle = {Scheme and Functional Programming Workshop},
  pages = {81-92},
  year = {2006}
}

@inproceedings{GradualRefined,
  title={Refined Criteria for Gradual Typing},
  author={Jeremy G. Siek and Michael M. Vitousek and Matteo Cimini and John Tang Boyland},
  booktitle={Summit on Advances in Programming Languages},
  year={2015},
  url={https://api.semanticscholar.org/CorpusID:15383644}
}

@book{PracticalFoundations,
  title = {Practical Foundations for Programming Languages: Second Edition},
  ISBN = {9781316576892},
  url = {http://dx.doi.org/10.1017/CBO9781316576892},
  DOI = {10.1017/cbo9781316576892},
  publisher = {Cambridge University Press},
  author = {Harper,  Robert},
  year = {2016},
  month = mar 
}

@article{CMTT,
  title = {Contextual modal type theory},
  volume = {9},
  ISSN = {1557-945X},
  url = {http://dx.doi.org/10.1145/1352582.1352591},
  DOI = {10.1145/1352582.1352591},
  number = {3},
  journal = {ACM Transactions on Computational Logic},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Nanevski,  Aleksandar and Pfenning,  Frank and Pientka,  Brigitte},
  year = {2008},
  month = jun,
  pages = {1–49}
}

@article{ModalStagedComputation,
author = {Davies, Rowan and Pfenning, Frank},
title = {A modal analysis of staged computation},
year = {2001},
issue_date = {May 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {3},
issn = {0004-5411},
url = {https://doi.org/10.1145/382780.382785},
doi = {10.1145/382780.382785},
abstract = {We show that a type system based on the intuitionistic modal logic S4 provides an expressive framework for specifying and analyzing computation stages in the context of typed λ-calculi and functional languages. We directly demonstrate the sense in which our λe→□-calculus captures staging, and also give a conservative embeddng of Nielson and Nielson's two-level functional language in our functional language Mini-ML□, thus proving that binding-time correctness is equivalent to modal correctness on this fragment. In addition, Mini-ML□ can also express immediate evaluation and sharing of code across multiple stages, thus supporting run-time code generation as well as partial evaluation.},
journal = {J. ACM},
month = may,
pages = {555–604},
numpages = {50},
keywords = {staged computation, run-time code generation, binding times}
}

@article{ModalJudgements,
  title = {A judgmental reconstruction of modal logic},
  volume = {11},
  ISSN = {1469-8072},
  url = {http://dx.doi.org/10.1017/S0960129501003322},
  DOI = {10.1017/s0960129501003322},
  number = {04},
  journal = {Mathematical Structures in Computer Science},
  publisher = {Cambridge University Press (CUP)},
  author = {PFENNING,  FRANK and DAVIES,  ROWAN},
  year = {2001},
  month = jul 
}

@article{FunctionalProgExplain,
  title = {Functional programs that explain their work},
  volume = {47},
  ISSN = {1558-1160},
  url = {http://dx.doi.org/10.1145/2398856.2364579},
  DOI = {10.1145/2398856.2364579},
  number = {9},
  journal = {ACM SIGPLAN Notices},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Perera,  Roly and Acar,  Umut A. and Cheney,  James and Levy,  Paul Blain},
  year = {2012},
  month = sep,
  pages = {365–376}
}

@article{MarkedLocalisation,
  title = {Total Type Error Localization and Recovery with Holes},
  volume = {8},
  ISSN = {2475-1421},
  url = {http://dx.doi.org/10.1145/3632910},
  DOI = {10.1145/3632910},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Zhao,  Eric and Maroof,  Raef and Dukkipati,  Anand and Blinn,  Andrew and Pan,  Zhiyi and Omar,  Cyrus},
  year = {2024},
  month = jan,
  pages = {2041–2068}
}

@misc{GradualJoins,
      title={Parameterized Cast Calculi and Reusable Meta-theory for Gradually Typed Lambda Calculi}, 
      author={Jeremy G. Siek},
      year={2021},
      eprint={2001.11560},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2001.11560}, 
}

@inproceedings{Gradualizer,
  series = {POPL ’16},
  title = {The gradualizer: a methodology and algorithm for generating gradual type systems},
  url = {http://dx.doi.org/10.1145/2837614.2837632},
  DOI = {10.1145/2837614.2837632},
  booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  publisher = {ACM},
  author = {Cimini,  Matteo and Siek,  Jeremy G.},
  year = {2016},
  month = jan,
  pages = {443–455},
  collection = {POPL ’16}
}

@inproceedings{GradualizerDynamic,
  series = {POPL ’17},
  title = {Automatically generating the dynamic semantics of gradually typed languages},
  volume = {7},
  url = {http://dx.doi.org/10.1145/3009837.3009863},
  DOI = {10.1145/3009837.3009863},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  publisher = {ACM},
  author = {Cimini,  Matteo and Siek,  Jeremy G.},
  year = {2017},
  month = jan,
  pages = {789–803},
  collection = {POPL ’17}
}

@book{TAPL,
author = {Pierce, Benjamin C.},
title = {Types and Programming Languages},
year = {2002},
isbn = {0262162091},
publisher = {The MIT Press},
edition = {1st},
abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@inproceedings{HashCons,
  series = {ICFP06},
  title = {Type-safe modular hash-consing},
  url = {http://dx.doi.org/10.1145/1159876.1159880},
  DOI = {10.1145/1159876.1159880},
  booktitle = {Proceedings of the 2006 workshop on ML},
  publisher = {ACM},
  author = {Filli\^atre,  Jean-Christophe and Conchon,  Sylvain},
  year = {2006},
  month = sep,
  collection = {ICFP06}
}
  
@article{Zipper,
  title = {The Zipper},
  volume = {7},
  ISSN = {1469-7653},
  url = {http://dx.doi.org/10.1017/S0956796897002864},
  DOI = {10.1017/s0956796897002864},
  number = {5},
  journal = {Journal of Functional Programming},
  publisher = {Cambridge University Press (CUP)},
  author = {HUET,  GÉRARD},
  year = {1997},
  month = sep,
  pages = {549–554}
}

@book{PurelyFunctionalDataStructures,
  title = {Purely Functional Data Structures},
  ISBN = {9780511530104},
  url = {http://dx.doi.org/10.1017/CBO9780511530104},
  DOI = {10.1017/cbo9780511530104},
  publisher = {Cambridge University Press},
  author = {Okasaki,  Chris},
  year = {1998},
  month = apr 
}    

@inbook{SemiPersistent,
  title = {Semi-persistent Data Structures},
  ISBN = {9783540787396},
  url = {http://dx.doi.org/10.1007/978-3-540-78739-6_25},
  DOI = {10.1007/978-3-540-78739-6_25},
  booktitle = {Programming Languages and Systems},
  publisher = {Springer Berlin Heidelberg},
  author = {Conchon,  Sylvain and Filli\^atre,  Jean-Christophe},
  pages = {322–336}
}

@article{WAM,
  title = "A Functional Derivation of the Warren Abstract Machine",
  author = "Maciej Pirog and Jeremy Gibbons",
  year = "2011",
  note = "Submitted for publication",
  url = "http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/wam.pdf",
}

@phdthesis{OLEG,
  title={Dependently typed functional programs and their proofs},
  author={McBride, Conor},
  year={2000},
  publisher={University of Edinburgh. College of Science and Engineering. School of~…},
  type={Doctoral Thesis}
}

@inproceedings{QuickCheck,
author = {Claessen, Koen and Hughes, John},
title = {QuickCheck: a lightweight tool for random testing of Haskell programs},
year = {2000},
isbn = {1581132026},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/351240.351266},
doi = {10.1145/351240.351266},
abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
booktitle = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
pages = {268–279},
numpages = {12},
series = {ICFP '00}
}

@article{SmallScope,
author = {Andoni, Alexandr and Daniliuc, Dumitru and Khurshid, Sarfraz and Marinov, Darko},
year = {2002},
month = {10},
pages = {},
title = {Evaluating the "Small Scope Hypothesis"}
}

@inproceedings{SmallCheck,
author = {Runciman, Colin and Naylor, Matthew and Lindblad, Fredrik},
title = {Smallcheck and lazy smallcheck: automatic exhaustive testing for small values},
year = {2008},
isbn = {9781605580647},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411286.1411292},
doi = {10.1145/1411286.1411292},
abstract = {This paper describes two Haskell libraries for property-based testing. Following the lead of QuickCheck, these testing libraries SmallCheck and Lazy SmallCheck also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with QuickCheck.},
booktitle = {Proceedings of the First ACM SIGPLAN Symposium on Haskell},
pages = {37–48},
numpages = {12},
keywords = {embedded language, exhaustive search, lazy evaluation, property-based testing, type classes},
location = {Victoria, BC, Canada},
series = {Haskell '08}
}

@article{DTI,
author = {Miyazaki, Yusuke and Sekiyama, Taro and Igarashi, Atsushi},
title = {Dynamic type inference for gradual Hindley–Milner typing},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290331},
doi = {10.1145/3290331},
abstract = {Garcia and Cimini study a type inference problem for the ITGL, an implicitly and gradually typed language with let-polymorphism, and develop a sound and complete inference algorithm for it. Soundness and completeness mean that, if the algorithm succeeds, the input term can be translated to a well-typed term of an explicitly typed blame calculus by cast insertion and vice versa. However, in general, there are many possible translations depending on how type variables that were left undecided by static type inference are instantiated with concrete static types. Worse, the translated terms may behave differently—some evaluate to values but others raise blame. In this paper, we propose and formalize a new blame calculus λBDTI that avoids such divergence as an intermediate language for the ITGL. A main idea is to allow a term to contain type variables (that have not been instantiated during static type inference) and defer instantiation of these type variables to run time. We introduce dynamic type inference (DTI) into the semantics of λBDTI so that type variables are instantiated along reduction. The DTI-based semantics not only avoids the divergence described above but also is sound and complete with respect to the semantics of fully instantiated terms in the following sense: if the evaluation of a term succeeds (i.e., terminates with a value) in the DTI-based semantics, then there is a fully instantiated version of the term that also succeeds in the explicitly typed blame calculus and vice versa. Finally, we prove the gradual guarantee, which is an important correctness criterion of a gradually typed language, for the ITGL.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {18},
numpages = {29},
keywords = {dynamic type inference, gradual guarantee, gradual typing}
}

@inproceedings{GradualTI,
author = {Garcia, Ronald and Cimini, Matteo},
title = {Principal Type Schemes for Gradual Programs},
year = {2015},
isbn = {9781450333009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2676726.2676992},
doi = {10.1145/2676726.2676992},
abstract = {Gradual typing is a discipline for integrating dynamic checking into a static type system. Since its introduction in functional languages, it has been adapted to a variety of type systems, including object-oriented, security, and substructural. This work studies its application to implicitly typed languages based on type inference. Siek and Vachharajani designed a gradual type inference system and algorithm that infers gradual types but still rejects ill-typed static programs. However, the type system requires local reasoning about type substitutions, an imperative inference algorithm, and a subtle correctness statement.This paper introduces a new approach to gradual type inference, driven by the principle that gradual inference should only produce static types. We present a static implicitly typed language, its gradual counterpart, and a type inference procedure. The gradual system types the same programs as Siek and Vachharajani, but has a modular structure amenable to extension. The language admits let-polymorphism, and its dynamics are defined by translation to the Polymorphic Blame Calculus.The principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing. To expose this difference, we distinguish static type parameters from gradual type parameters and reinterpret gradual type consistency accordingly. The resulting extension enables programs to be interpreted using either the polymorphic or monomorphic Blame Calculi.},
booktitle = {Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {303–315},
numpages = {13},
keywords = {type inference, gradual typing},
location = {Mumbai, India},
series = {POPL '15}
}


@inproceedings{EffectsHaskell,
author = {Xie, Ningning and Leijen, Daan},
title = {Effect handlers in Haskell, evidently},
year = {2020},
isbn = {9781450380508},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3406088.3409022},
doi = {10.1145/3406088.3409022},
abstract = {Algebraic effect handlers offer an alternative to monads to incorporate effects in Haskell. In recent work Xie _et al._ show how to give semantics to effect handlers in terms of plain polymorphic lambda calculus through _evidence translation_. Besides giving precise semantics, this translation also allows for potentially more efficient implementations. Here we present the first implementation of this technique as a library for effect handlers in Haskell. We show how the design naturally leads to a concise effect interface and how evidence translation enables evaluating _tail resumptive_ operations _in-place_. We give detailed benchmark results where our library performs well with respect to other approaches.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Haskell},
pages = {95–108},
numpages = {14},
keywords = {Algebraic Effects, Evidence Passing Translation, Handlers},
location = {Virtual Event, USA},
series = {Haskell 2020}
}

@inproceedings{DebugTimeSelfReport,
author = {Beller, Moritz and Spruit, Niels and Spinellis, Diomidis and Zaidman, Andy},
title = {On the dichotomy of debugging behavior among programmers},
year = {2018},
isbn = {9781450356381},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3180155.3180175},
doi = {10.1145/3180155.3180175},
abstract = {Debugging is an inevitable activity in most software projects, often difficult and more time-consuming than expected, giving it the nickname the "dirty little secret of computer science." Surprisingly, we have little knowledge on how software engineers debug software problems in the real world, whether they use dedicated debugging tools, and how knowledgeable they are about debugging. This study aims to shed light on these aspects by following a mixed-methods research approach. We conduct an online survey capturing how 176 developers reflect on debugging. We augment this subjective survey data with objective observations on how 458 developers use the debugger included in their integrated development environments (IDEs) by instrumenting the popular Eclipse and IntelliJ IDEs with the purpose-built plugin WatchDog 2.0. To clarify the insights and discrepancies observed in the previous steps, we followed up by conducting interviews with debugging experts and regular debugging users. Our results indicate that IDE-provided debuggers are not used as often as expected, as "printf debugging" remains a feasible choice for many programmers. Furthermore, both knowledge and use of advanced debugging features are low. These results call to strengthen hands-on debugging experience in computer science curricula and have already refined the implementation of modern IDE debuggers.},
booktitle = {Proceedings of the 40th International Conference on Software Engineering},
pages = {572–583},
numpages = {12},
location = {Gothenburg, Sweden},
series = {ICSE '18}
}

@misc{DebugSkew,
      title={An Exploratory Study of Debugging Episodes}, 
      author={Abdulaziz Alaboudi and Thomas D. LaToza},
      year={2021},
      eprint={2105.02162},
      archivePrefix={arXiv},
      primaryClass={cs.SE},
      url={https://arxiv.org/abs/2105.02162}, 
}

@article{StudentTypeErrorFixes,
author = {Wu, Baijun and Chen, Sheng},
title = {How type errors were fixed and what students did?},
year = {2017},
issue_date = {October 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {OOPSLA},
url = {https://doi.org/10.1145/3133929},
doi = {10.1145/3133929},
abstract = {Providing better supports for debugging type errors has been an active research area in the last three decades. Numerous approaches from different perspectives have been developed. Most approaches work well under certain conditions only, for example, when type errors are caused by single leaves and when type annotations are correct. However, the research community is still unaware of which conditions hold in practice and what the real debugging situations look like. We address this problem with a study of 3 program data sets, which were written in different years, using different compilers, and were of diverse sizes. They include more than 55,000 programs, among which more than 2,700 are ill typed. We investigated all the ill-typed programs, and our results indicate that current error debugging support is far from sufficient in practice since only about 35\% of all type errors were caused by single leaves. In addition, type annotations cannot always be trusted in error debuggers since about 30\% of the time type errors were caused by wrong type annotations. Our study also provides many insights about the debugging behaviors of students in functional programming, which could be exploited for developing more effective error debuggers.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {105},
numpages = {27},
keywords = {type inference, empirical study, Type-error debugging}
}

@INPROCEEDINGS{HowFixBugs,
  author={Coker, Zack and Widder, David Gray and Le Goues, Claire and Bogart, Christopher and Sunshine, Joshua},
  booktitle={2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)}, 
  title={A Qualitative Study on Framework Debugging}, 
  year={2019},
  volume={},
  number={},
  pages={568-579},
  keywords={Debugging;Task analysis;Androids;Humanoid robots;Encoding;Protocols;Frameworks;Debugging;Qualitative study},
  doi={10.1109/ICSME.2019.00091}}

@INPROCEEDINGS{DebugNeeds,
  author={Layman, Lucas and Diep, Madeline and Nagappan, Meiyappan and Singer, Janice and Deline, Robert and Venolia, Gina},
  booktitle={2013 ACM / IEEE International Symposium on Empirical Software Engineering and Measurement}, 
  title={Debugging Revisited: Toward Understanding the Debugging Needs of Contemporary Software Developers}, 
  year={2013},
  volume={},
  number={},
  pages={383-392},
  keywords={Debugging;Interviews;Encoding;Computer bugs;Web services;Testing;debugging;software engineering;interview;professionals;qualitative analysis;program comprehension},
  doi={10.1109/ESEM.2013.43}}

@article{LogicProg,
  title={Applied logic: its use and implementation as a programming tool},
  author={Warren, David HD},
  year={1978},
  publisher={The University of Edinburgh}
}

@article{ModeCorrectness,
  title={Adding redundancy to obtain more reliable and more readable prolog programs},
  author={Bruynooghe, Maurice},
  journal={CW Reports},
  pages={5--5},
  year={1982},
  publisher={Department of Computer Science, KU Leuven, Leuven, Belgium}
}
@book{ATTAPL,
  title={Advanced topics in types and programming languages},
  author={Pierce, Benjamin C},
  year={2024},
  publisher={MIT press}
}



@article{SystemFUndecidable,
title = {Typability and type checking in System F are equivalent and undecidable},
journal = {Annals of Pure and Applied Logic},
volume = {98},
number = {1},
pages = {111-156},
year = {1999},
issn = {0168-0072},
doi = {https://doi.org/10.1016/S0168-0072(98)00047-5},
url = {https://www.sciencedirect.com/science/article/pii/S0168007298000475},
author = {J.B. Wells},
keywords = {System F, Semi-unification, Type inference, Typability, Type checking, Lambda calculus},
abstract = {Girard and Reynolds independently invented System F (a.k.a. the second-order polymorphically typed lambda calculus) to handle problems in logic and computer programming language design, respectively. Viewing F in the Curry style, which associates types with untyped lambda terms, raises the questions of typability and type checking. Typability asks for a term whether there exists some type it can be given. Type checking asks, for a particular term and type, whether the term can be given that type. The decidability of these problems has been settled for restrictions and extensions of F and related systems and complexity lower-bounds have been determined for typability in F, but this report is the first to resolve whether these problems are decidable for System F. This report proves that type checking in F is undecidable, by a reduction from semi-unification, and that typability in F is undecidable, by a reduction from type checking. Because there is an easy reduction from typability to type checking, the two problems are equivalent. The reduction from type checking to typability uses a novel method of constructing lambda terms that simulate arbitrarily chosen type environments. All of the results also hold for the λI-calculus.}
}

@ARTICLE{TraceVisualisation,
  author={Cornelissen, Bas and Zaidman, Andy and van Deursen, Arie},
  journal={IEEE Transactions on Software Engineering}, 
  title={A Controlled Experiment for Program Comprehension through Trace Visualization}, 
  year={2011},
  volume={37},
  number={3},
  pages={341-355},
  keywords={Visualization;Computer Society;Time measurement;Programming;Documentation;Scalability;Software maintenance;Gain measurement;Control systems;Performance evaluation;Program comprehension;dynamic analysis;controlled experiment.},
  doi={10.1109/TSE.2010.47}}

  @ARTICLE{DynamicLangShift,
  author={Paulson, Linda Dailey},
  journal={Computer}, 
  title={Developers shift to dynamic programming languages}, 
  year={2007},
  volume={40},
  number={2},
  pages={12-15},
  keywords={Dynamic programming;Java;Runtime;Programming profession;Application software;Computer languages;Error correction;Testing;Mission critical systems;Memory management;dynamic programming languages;PHP;Perl;Ruby},
  doi={10.1109/MC.2007.53}}

@misc{TIOBE,
  author       = {TIOBE Software},
  title        = {TIOBE Programming Community Index},
  year         = 2025,
  url          = {https://www.tiobe.com/tiobe-index/},
  note         = {[Online; accessed 27-February-2025]}
}

@inproceedings{DynamicTyping,
author = {Abadi, M. and Cardelli, L. and Pierce, B. and Plotkin, G.},
title = {Dynamic typing in a statically-typed language},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75296},
doi = {10.1145/75277.75296},
abstract = {Statically-typed programming languages allow earlier error checking, better enforcement of disciplined programming styles, and generation of more efficient object code than languages where all type-consistency checks are performed at runtime. However, even in statically-type languages, there is often the need to deal with data whose type cannot be known at compile time. To handle such situations safely, we propose to add a type Dynamic whose values are pairs of a value v and a type tag T where v has the type denoted by T. Instances of Dynamic are built with an explicit tagging construct and inspected with a type-safe typecase construct.This paper is an exploration of the syntax, operational semantics, and denotational semantics of a simple language with the type Dynamic. We give examples of how dynamically-typed values might be used in programming. Then we discuss an operational semantics for our language and obtain a soundness theorem. We present two formulations of the denotational semantics of this language and relate them to the operational semantics. Finally, we consider the implications of polymorphism and some implementation issues.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {213–227},
numpages = {15},
location = {Austin, Texas, USA},
series = {POPL '89}
}

@inproceedings{SemanticCasts,
  title={Semantic casts: Contracts and structural subtyping in a nominal world},
  author={Findler, Robert Bruce and Flatt, Matthew and Felleisen, Matthias},
  booktitle={European Conference on Object-Oriented Programming},
  pages={365--389},
  year={2004},
  organization={Springer}
}

@article{Contracts,
author = {Findler, Robert Bruce and Felleisen, Matthias},
title = {Contracts for higher-order functions},
year = {2002},
issue_date = {September 2002},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {37},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/583852.581484},
doi = {10.1145/583852.581484},
abstract = {Assertions play an important role in the construction of robust software. Their use in programming languages dates back to the 1970s. Eiffel, an object-oriented programming language, wholeheartedly adopted assertions and developed the "Design by Contract" philosophy. Indeed, the entire object-oriented community recognizes the value of assertion-based contracts on methods.In contrast, languages with higher-order functions do not support assertion-based contracts. Because predicates on functions are, in general, undecidable, specifying such predicates appears to be meaningless. Instead, the functional languages community developed type systems that statically approximate interesting predicates.In this paper, we show how to support higher-order function contracts in a theoretically well-founded and practically viable manner. Specifically, we introduce λcon, a typed lambda calculus with assertions for higher-order functions. The calculus models the assertion monitoring system that we employ in DrScheme. We establish basic properties of the model (type soundness, etc.) and illustrate the usefulness of contract checking with examples from DrScheme's code base.We believe that the development of an assertion system for higher-order functions serves two purposes. On one hand, the system has strong practical potential because existing type systems simply cannot express many assertions that programmers would like to state. On the other hand, an inspection of a large base of invariants may provide inspiration for the direction of practical future type system research.},
journal = {SIGPLAN Not.},
month = sep,
pages = {48–59},
numpages = {12},
keywords = {behavioral specifications, contracts, higher-order functions, predicate typing, solfware reliability}
}


@book{BasicCatTheory,
  title={Basic category theory for computer scientists},
  author={Pierce, Benjamin C},
  year={1991},
  publisher={MIT press}
}

@article{OneHoleContext,
  title={The derivative of a regular type is its type of one-hole contexts},
  author={McBride, Conor},
  journal={Unpublished manuscript},
  pages={74--88},
  year={2001}
}

@article{TypeDerivatives,
author = {McBride, Conor},
title = {Clowns to the left of me, jokers to the right (pearl): dissecting data structures},
year = {2008},
issue_date = {January 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1328897.1328474},
doi = {10.1145/1328897.1328474},
abstract = {This paper introduces a small but useful generalisation to the 'derivative' operation on datatypes underlying Huet's notion of 'zipper', giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, 'dissection', turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right.I present dissection here as a generic program, albeit for polynomial functors only. The notion is certainly applicable more widely, but here I prefer to concentrate on its diverse applications. For a start, map-like operations over the functor and fold-like operations over the recursive data structure it induces can be expressed by tail recursion alone. Further, the derivative is readily recovered from the dissection. Indeed, it is the dissection structure which delivers Huet's operations for navigating zippers.The original motivation for dissection was to define 'division', capturing the notion of leftmost hole, canonically distinguishing values with no elements from those with at least one. Division gives rise to an isomorphism corresponding to the remainder theorem in algebra. By way of a larger example, division and dissection are exploited to give a relatively efficient generic algorithm for abstracting all occurrences of one term from another in a first-order syntax. The source code for the paper is available online and compiles with recent extensions to the Glasgow Haskell Compiler.},
journal = {SIGPLAN Not.},
month = jan,
pages = {287–295},
numpages = {9},
keywords = {datatype, differentiation, dissection, division, generic programming, iteration, polynomial, stack, tail recursion, traversal, zipper}
}



@book{RealWorldOCaml,
  title={Real World OCaml: Functional programming for the masses},
  author={Minsky, Yaron and Madhavapeddy, Anil and Hickey, Jason},
  year={2013},
  publisher={" O'Reilly Media, Inc."}
}

@techreport{PolymorphicVariants,
  title={A polymorphic type system for extensible records and variants},
  author={Gaster, Benedict R and Jones, Mark P},
  year={1996},
  institution={Technical Report NOTTCS-TR-96-3, Department of Computer Science, University~…}
}

@inproceedings{StructuralSubtyping,
  title={Structural subtyping and the notion of power type},
  author={Cardelli, Luca},
  booktitle={Proceedings of the 15th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={70--79},
  year={1988}
}

@article{LivePatternMatching,
author = {Yuan, Yongwei and Guest, Scott and Griffis, Eric and Potter, Hannah and Moon, David and Omar, Cyrus},
title = {Live Pattern Matching with Typed Holes},
year = {2023},
issue_date = {April 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3586048},
doi = {10.1145/3586048},
abstract = {Several modern programming systems, including GHC Haskell, Agda, Idris, and Hazel, support typed holes. Assigning static and, to varying degree, dynamic meaning to programs with holes allows program editors and other tools to offer meaningful feedback and assistance throughout editing, i.e. in a live manner. Prior work, however, has considered only holes appearing in expressions and types. This paper considers, from type theoretic and logical first principles, the problem of typed pattern holes. We confront two main difficulties, (1) statically reasoning about exhaustiveness and irredundancy when patterns are not fully known, and (2) live evaluation of expressions containing both pattern and expression holes. In both cases, this requires reasoning conservatively about all possible hole fillings. We develop a typed lambda calculus, Peanut, where reasoning about exhaustiveness and redundancy is mapped to the problem of deriving first order entailments. We equip Peanut with an operational semantics in the style of Hazelnut Live that allows us to evaluate around holes in both expressions and patterns. We mechanize the metatheory of Peanut in Agda and formalize a procedure capable of deciding the necessary entailments. Finally, we scale up and implement these mechanisms within Hazel, a programming environment for a dialect of Elm that automatically inserts holes during editing to provide static and dynamic feedback to the programmer in a maximally live manner, i.e. for every possible editor state. Hazel is the first maximally live environment for a general-purpose functional language.},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {96},
numpages = {27},
keywords = {typed holes, pattern matching}
}

@inbook{PracticalFoundationsEd1, place={Cambridge}, title={Contents}, booktitle={Practical Foundations for Programming Languages}, publisher={Cambridge University Press}, author={Harper, Robert}, year={2012}, pages={v–xvi}}

@article{NondeterministicAlgorithms,
author = {Floyd, Robert W.},
title = {Nondeterministic Algorithms},
year = {1967},
issue_date = {Oct. 1967},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {4},
issn = {0004-5411},
url = {https://doi.org/10.1145/321420.321422},
doi = {10.1145/321420.321422},
abstract = {Programs to solve combinatorial search problems may often be simply written by using multiple-valued functions. Such programs, although impossible to execute directly on conventional computers, may be converted in a mechanical way into conventional backtracking programs. The process is illustrated with algorithms to find all solutions to the eight queens problem on the chessboard, and to find all simple cycles in a network.},
journal = {J. ACM},
month = oct,
pages = {636–644},
numpages = {9}
}

@article{NondetDSL,
   title={Effects Without Monads: Non-determinism – Back to the Meta Language},
   volume={294},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.294.2},
   DOI={10.4204/eptcs.294.2},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Kiselyov, Oleg},
   year={2019},
   month=may, pages={15–40} }
   
   @Inbook{TaglessFinalDSL,
author="Kiselyov, Oleg",
editor="Gibbons, Jeremy",
title="Typed Tagless Final Interpreters",
bookTitle="Generic and Indexed Programming: International Spring School, SSGIP 2010, Oxford, UK, March 22-26, 2010, Revised Lectures",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="130--174",
abstract="The so-called `typed tagless final' approach of [6] has collected and polished a number of techniques for representing typed higher-order languages in a typed metalanguage, along with type-preserving interpretation, compilation and partial evaluation. The approach is an alternative to the traditional, or `initial' encoding of an object language as a (generalized) algebraic data type. Both approaches permit multiple interpretations of an expression, to evaluate it, pretty-print, etc. The final encoding represents all and only typed object terms without resorting to generalized algebraic data types, dependent or other fancy types. The final encoding lets us add new language forms and interpretations without breaking the existing terms and interpreters.",
isbn="978-3-642-32202-0",
doi="10.1007/978-3-642-32202-0_3",
url="https://doi.org/10.1007/978-3-642-32202-0_3"
}


