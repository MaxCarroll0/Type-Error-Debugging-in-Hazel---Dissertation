@inproceedings{SearchProc,
  series = {ICFP’16},
  title = {Dynamic witnesses for static type errors (or,  ill-typed programs usually go wrong)},
  url = {http://dx.doi.org/10.1145/2951913.2951915},
  DOI = {10.1145/2951913.2951915},
  booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
  publisher = {ACM},
  author = {Seidel,  Eric L. and Jhala,  Ranjit and Weimer,  Westley},
  year = {2016},
  month = sep,
  pages = {228–242},
  collection = {ICFP’16}
}@online{Hazel,
title = {Hazel Project Website},
url = {https://hazel.org/},
OPTurldate = {2022-10-11},
}
@online{HazelCode,
title = {Hazel Source Code},
url = {https://github.com/hazelgrove/hazel},
OPTurldate = {2022-10-11},
}

@online{ConcurrentZipper,
title = {Generic Zippers},
url = {https://okmij.org/ftp/continuations/zipper.html},
author = {Oleg Kiselyov}
}

@online{MultiZipper,
title = {Multi Zippers},
url = {https://pavpanchekha.com/blog/zippers/multi-zippers.html#org1556357},
author = {Pavel Panchekha}}

@inbook{Blame,
  title = {Well-Typed Programs Can’t Be Blamed},
  ISBN = {9783642005909},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-642-00590-9_1},
  DOI = {10.1007/978-3-642-00590-9_1},
  booktitle = {Programming Languages and Systems},
  publisher = {Springer Berlin Heidelberg},
  author = {Wadler,  Philip and Findler,  Robert Bruce},
  year = {2009},
  pages = {1–16}
}

@article{ErrSlice,
  title = {A slicing-based approach for locating type errors},
  volume = {10},
  ISSN = {1557-7392},
  url = {http://dx.doi.org/10.1145/366378.366379},
  DOI = {10.1145/366378.366379},
  number = {1},
  journal = {ACM Transactions on Software Engineering and Methodology},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Tip,  F. and Dinesh,  T. B.},
  year = {2001},
  month = jan,
  pages = {5–55}
}

@article{HaackErrSlice,
  title = {Type error slicing in implicitly typed higher-order languages},
  volume = {50},
  ISSN = {0167-6423},
  url = {http://dx.doi.org/10.1016/j.scico.2004.01.004},
  DOI = {10.1016/j.scico.2004.01.004},
  number = {1–3},
  journal = {Science of Computer Programming},
  publisher = {Elsevier BV},
  author = {Haack,  Christian and Wells,  J.B.},
  year = {2004},
  month = mar,
  pages = {189–224}
}

@inbook{ConstraintFreeErrSlice,
  title = {Constraint-Free Type Error Slicing},
  ISBN = {9783642320378},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-642-32037-8_1},
  DOI = {10.1007/978-3-642-32037-8_1},
  booktitle = {Trends in Functional Programming},
  publisher = {Springer Berlin Heidelberg},
  author = {Schilling,  Thomas},
  year = {2012},
  pages = {1–16}
}

@article{DynProgSlice,
  title = {Dynamic program slicing},
  volume = {29},
  ISSN = {0020-0190},
  url = {http://dx.doi.org/10.1016/0020-0190(88)90054-3},
  DOI = {10.1016/0020-0190(88)90054-3},
  number = {3},
  journal = {Information Processing Letters},
  publisher = {Elsevier BV},
  author = {Korel,  Bogdan and Laski,  Janusz},
  year = {1988},
  month = oct,
  pages = {155–163}
}
@article{ProgSlice,
  doi = {10.7302/11363},
  url = {http://deepblue.lib.umich.edu/handle/2027.42/180974},
  author = {Weiser,  Mark David},
  title = {Program Slices: Formal,  Psychological,  And Practical Investigations Of An Automatic Program Abstraction Method.},
  publisher = {My University},
  year = {1979}
}

@article{HazelLivePaper,
  title = {Live functional programming with typed holes},
  volume = {3},
  ISSN = {2475-1421},
  url = {http://dx.doi.org/10.1145/3290327},
  DOI = {10.1145/3290327},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Omar,  Cyrus and Voysey,  Ian and Chugh,  Ravi and Hammer,  Matthew A.},
  year = {2019},
  month = jan,
  pages = {1–32}
}

@inbook{StandardMLTypeTheory,
  title = {A Type-Theoretic Interpretation of Standard ML},
  ISBN = {9780262281676},
  url = {http://dx.doi.org/10.7551/mitpress/5641.003.0019},
  DOI = {10.7551/mitpress/5641.003.0019},
  booktitle = {Proof,  Language,  and Interaction},
  publisher = {The MIT Press},
  author = {Harper,  Robert and Stone,  Christopher},
  year = {2000},
  month = may,
  pages = {341–388}
}

@article{CoreXML,
  title = {On the type structure of standard ML},
  volume = {15},
  ISSN = {1558-4593},
  url = {http://dx.doi.org/10.1145/169701.169696},
  DOI = {10.1145/169701.169696},
  number = {2},
  journal = {ACM Transactions on Programming Languages and Systems},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Harper,  Robert and Mitchell,  John C.},
  year = {1993},
  month = apr,
  pages = {211–252}
}

@article{LocalInference,
  title = {Local type inference},
  volume = {22},
  ISSN = {1558-4593},
  url = {http://dx.doi.org/10.1145/345099.345100},
  DOI = {10.1145/345099.345100},
  number = {1},
  journal = {ACM Transactions on Programming Languages and Systems},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Pierce,  Benjamin C. and Turner,  David N.},
  year = {2000},
  month = jan,
  pages = {1–44}
}

@inproceedings{BidirectionalTypes,
  series = {ICFP’13},
  title = {Complete and easy bidirectional typechecking for higher-rank polymorphism},
  url = {http://dx.doi.org/10.1145/2500365.2500582},
  DOI = {10.1145/2500365.2500582},
  booktitle = {Proceedings of the 18th ACM SIGPLAN international conference on Functional programming},
  publisher = {ACM},
  author = {Dunfield,  Jana and Krishnaswami,  Neelakantan R.},
  year = {2013},
  month = sep,
  collection = {ICFP’13}
}

@inbook{GradualObjects,
  title = {Gradual Typing for Objects},
  ISBN = {9783540735892},
  ISSN = {1611-3349},
  url = {http://dx.doi.org/10.1007/978-3-540-73589-2_2},
  DOI = {10.1007/978-3-540-73589-2_2},
  booktitle = {ECOOP 2007 – Object-Oriented Programming},
  publisher = {Springer Berlin Heidelberg},
  author = {Siek,  Jeremy and Taha,  Walid},
  year = {2007},
  pages = {2–27}
}

@inbook{GradualFunctional,
  title = {Gradual Typing for Functional Languages}
}

@book{PracticalFoundations,
  title = {Practical Foundations for Programming Languages},
  ISBN = {9781316576892},
  url = {http://dx.doi.org/10.1017/CBO9781316576892},
  DOI = {10.1017/cbo9781316576892},
  publisher = {Cambridge University Press},
  author = {Harper,  Robert},
  year = {2016},
  month = mar 
}

@article{CMTT,
  title = {Contextual modal type theory},
  volume = {9},
  ISSN = {1557-945X},
  url = {http://dx.doi.org/10.1145/1352582.1352591},
  DOI = {10.1145/1352582.1352591},
  number = {3},
  journal = {ACM Transactions on Computational Logic},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Nanevski,  Aleksandar and Pfenning,  Frank and Pientka,  Brigitte},
  year = {2008},
  month = jun,
  pages = {1–49}
}

@article{ModalStagedComputation,
author = {Davies, Rowan and Pfenning, Frank},
title = {A modal analysis of staged computation},
year = {2001},
issue_date = {May 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {3},
issn = {0004-5411},
url = {https://doi.org/10.1145/382780.382785},
doi = {10.1145/382780.382785},
abstract = {We show that a type system based on the intuitionistic modal logic S4 provides an expressive framework for specifying and analyzing computation stages in the context of typed λ-calculi and functional languages. We directly demonstrate the sense in which our λe→□-calculus captures staging, and also give a conservative embeddng of Nielson and Nielson's two-level functional language in our functional language Mini-ML□, thus proving that binding-time correctness is equivalent to modal correctness on this fragment. In addition, Mini-ML□ can also express immediate evaluation and sharing of code across multiple stages, thus supporting run-time code generation as well as partial evaluation.},
journal = {J. ACM},
month = may,
pages = {555–604},
numpages = {50},
keywords = {staged computation, run-time code generation, binding times}
}

@article{ModalJudgements,
  title = {A judgmental reconstruction of modal logic},
  volume = {11},
  ISSN = {1469-8072},
  url = {http://dx.doi.org/10.1017/S0960129501003322},
  DOI = {10.1017/s0960129501003322},
  number = {04},
  journal = {Mathematical Structures in Computer Science},
  publisher = {Cambridge University Press (CUP)},
  author = {PFENNING,  FRANK and DAVIES,  ROWAN},
  year = {2001},
  month = jul 
}

@article{FunctionalProgExplain,
  title = {Functional programs that explain their work},
  volume = {47},
  ISSN = {1558-1160},
  url = {http://dx.doi.org/10.1145/2398856.2364579},
  DOI = {10.1145/2398856.2364579},
  number = {9},
  journal = {ACM SIGPLAN Notices},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Perera,  Roly and Acar,  Umut A. and Cheney,  James and Levy,  Paul Blain},
  year = {2012},
  month = sep,
  pages = {365–376}
}

@article{MarkedLocalisation,
  title = {Total Type Error Localization and Recovery with Holes},
  volume = {8},
  ISSN = {2475-1421},
  url = {http://dx.doi.org/10.1145/3632910},
  DOI = {10.1145/3632910},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {Association for Computing Machinery (ACM)},
  author = {Zhao,  Eric and Maroof,  Raef and Dukkipati,  Anand and Blinn,  Andrew and Pan,  Zhiyi and Omar,  Cyrus},
  year = {2024},
  month = jan,
  pages = {2041–2068}
}

@inproceedings{Gradualizer,
  series = {POPL ’16},
  title = {The gradualizer: a methodology and algorithm for generating gradual type systems},
  url = {http://dx.doi.org/10.1145/2837614.2837632},
  DOI = {10.1145/2837614.2837632},
  booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  publisher = {ACM},
  author = {Cimini,  Matteo and Siek,  Jeremy G.},
  year = {2016},
  month = jan,
  pages = {443–455},
  collection = {POPL ’16}
}

@inproceedings{GradualizerDynamic,
  series = {POPL ’17},
  title = {Automatically generating the dynamic semantics of gradually typed languages},
  volume = {7},
  url = {http://dx.doi.org/10.1145/3009837.3009863},
  DOI = {10.1145/3009837.3009863},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  publisher = {ACM},
  author = {Cimini,  Matteo and Siek,  Jeremy G.},
  year = {2017},
  month = jan,
  pages = {789–803},
  collection = {POPL ’17}
}

@book{TAPL,
author = {Pierce, Benjamin C.},
title = {Types and Programming Languages},
year = {2002},
isbn = {0262162091},
publisher = {The MIT Press},
edition = {1st},
abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@inproceedings{HashCons,
  series = {ICFP06},
  title = {Type-safe modular hash-consing},
  url = {http://dx.doi.org/10.1145/1159876.1159880},
  DOI = {10.1145/1159876.1159880},
  booktitle = {Proceedings of the 2006 workshop on ML},
  publisher = {ACM},
  author = {Filli\^atre,  Jean-Christophe and Conchon,  Sylvain},
  year = {2006},
  month = sep,
  collection = {ICFP06}
}
  
@article{Zipper,
  title = {The Zipper},
  volume = {7},
  ISSN = {1469-7653},
  url = {http://dx.doi.org/10.1017/S0956796897002864},
  DOI = {10.1017/s0956796897002864},
  number = {5},
  journal = {Journal of Functional Programming},
  publisher = {Cambridge University Press (CUP)},
  author = {HUET,  GÉRARD},
  year = {1997},
  month = sep,
  pages = {549–554}
}

@book{PurelyFunctionalDataStructures,
  title = {Purely Functional Data Structures},
  ISBN = {9780511530104},
  url = {http://dx.doi.org/10.1017/CBO9780511530104},
  DOI = {10.1017/cbo9780511530104},
  publisher = {Cambridge University Press},
  author = {Okasaki,  Chris},
  year = {1998},
  month = apr 
}    

@inbook{SemiPersistent,
  title = {Semi-persistent Data Structures},
  ISBN = {9783540787396},
  url = {http://dx.doi.org/10.1007/978-3-540-78739-6_25},
  DOI = {10.1007/978-3-540-78739-6_25},
  booktitle = {Programming Languages and Systems},
  publisher = {Springer Berlin Heidelberg},
  author = {Conchon,  Sylvain and Filli\^atre,  Jean-Christophe},
  pages = {322–336}
}

@article{WAM,
  title = "A Functional Derivation of the Warren Abstract Machine",
  author = "Maciej Pirog and Jeremy Gibbons",
  year = "2011",
  note = "Submitted for publication",
  url = "http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/wam.pdf",
}

@phdthesis{OLEG,
  title={Dependently typed functional programs and their proofs},
  author={McBride, Conor},
  year={2000},
  publisher={University of Edinburgh. College of Science and Engineering. School of~…},
  type={Doctoral Thesis}
}

@inproceedings{QuickCheck,
author = {Claessen, Koen and Hughes, John},
title = {QuickCheck: a lightweight tool for random testing of Haskell programs},
year = {2000},
isbn = {1581132026},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/351240.351266},
doi = {10.1145/351240.351266},
abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
booktitle = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
pages = {268–279},
numpages = {12},
series = {ICFP '00}
}

@article{SmallScope,
author = {Andoni, Alexandr and Daniliuc, Dumitru and Khurshid, Sarfraz and Marinov, Darko},
year = {2002},
month = {10},
pages = {},
title = {Evaluating the "Small Scope Hypothesis"}
}

@inproceedings{SmallCheck,
author = {Runciman, Colin and Naylor, Matthew and Lindblad, Fredrik},
title = {Smallcheck and lazy smallcheck: automatic exhaustive testing for small values},
year = {2008},
isbn = {9781605580647},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411286.1411292},
doi = {10.1145/1411286.1411292},
abstract = {This paper describes two Haskell libraries for property-based testing. Following the lead of QuickCheck, these testing libraries SmallCheck and Lazy SmallCheck also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with QuickCheck.},
booktitle = {Proceedings of the First ACM SIGPLAN Symposium on Haskell},
pages = {37–48},
numpages = {12},
keywords = {embedded language, exhaustive search, lazy evaluation, property-based testing, type classes},
location = {Victoria, BC, Canada},
series = {Haskell '08}
}

@article{DTI,
author = {Miyazaki, Yusuke and Sekiyama, Taro and Igarashi, Atsushi},
title = {Dynamic type inference for gradual Hindley–Milner typing},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290331},
doi = {10.1145/3290331},
abstract = {Garcia and Cimini study a type inference problem for the ITGL, an implicitly and gradually typed language with let-polymorphism, and develop a sound and complete inference algorithm for it. Soundness and completeness mean that, if the algorithm succeeds, the input term can be translated to a well-typed term of an explicitly typed blame calculus by cast insertion and vice versa. However, in general, there are many possible translations depending on how type variables that were left undecided by static type inference are instantiated with concrete static types. Worse, the translated terms may behave differently—some evaluate to values but others raise blame. In this paper, we propose and formalize a new blame calculus λBDTI that avoids such divergence as an intermediate language for the ITGL. A main idea is to allow a term to contain type variables (that have not been instantiated during static type inference) and defer instantiation of these type variables to run time. We introduce dynamic type inference (DTI) into the semantics of λBDTI so that type variables are instantiated along reduction. The DTI-based semantics not only avoids the divergence described above but also is sound and complete with respect to the semantics of fully instantiated terms in the following sense: if the evaluation of a term succeeds (i.e., terminates with a value) in the DTI-based semantics, then there is a fully instantiated version of the term that also succeeds in the explicitly typed blame calculus and vice versa. Finally, we prove the gradual guarantee, which is an important correctness criterion of a gradually typed language, for the ITGL.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {18},
numpages = {29},
keywords = {dynamic type inference, gradual guarantee, gradual typing}
}

@article{10.1145/2775051.2676992,
author = {Garcia, Ronald and Cimini, Matteo},
title = {Principal Type Schemes for Gradual Programs},
year = {2015},
issue_date = {January 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2775051.2676992},
doi = {10.1145/2775051.2676992},
abstract = {Gradual typing is a discipline for integrating dynamic checking into a static type system. Since its introduction in functional languages, it has been adapted to a variety of type systems, including object-oriented, security, and substructural. This work studies its application to implicitly typed languages based on type inference. Siek and Vachharajani designed a gradual type inference system and algorithm that infers gradual types but still rejects ill-typed static programs. However, the type system requires local reasoning about type substitutions, an imperative inference algorithm, and a subtle correctness statement.This paper introduces a new approach to gradual type inference, driven by the principle that gradual inference should only produce static types. We present a static implicitly typed language, its gradual counterpart, and a type inference procedure. The gradual system types the same programs as Siek and Vachharajani, but has a modular structure amenable to extension. The language admits let-polymorphism, and its dynamics are defined by translation to the Polymorphic Blame Calculus.The principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing. To expose this difference, we distinguish static type parameters from gradual type parameters and reinterpret gradual type consistency accordingly. The resulting extension enables programs to be interpreted using either the polymorphic or monomorphic Blame Calculi.},
journal = {SIGPLAN Not.},
month = jan,
pages = {303–315},
numpages = {13},
keywords = {type inference, gradual typing}
}

@inproceedings{GradualTI,
author = {Garcia, Ronald and Cimini, Matteo},
title = {Principal Type Schemes for Gradual Programs},
year = {2015},
isbn = {9781450333009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2676726.2676992},
doi = {10.1145/2676726.2676992},
abstract = {Gradual typing is a discipline for integrating dynamic checking into a static type system. Since its introduction in functional languages, it has been adapted to a variety of type systems, including object-oriented, security, and substructural. This work studies its application to implicitly typed languages based on type inference. Siek and Vachharajani designed a gradual type inference system and algorithm that infers gradual types but still rejects ill-typed static programs. However, the type system requires local reasoning about type substitutions, an imperative inference algorithm, and a subtle correctness statement.This paper introduces a new approach to gradual type inference, driven by the principle that gradual inference should only produce static types. We present a static implicitly typed language, its gradual counterpart, and a type inference procedure. The gradual system types the same programs as Siek and Vachharajani, but has a modular structure amenable to extension. The language admits let-polymorphism, and its dynamics are defined by translation to the Polymorphic Blame Calculus.The principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing. To expose this difference, we distinguish static type parameters from gradual type parameters and reinterpret gradual type consistency accordingly. The resulting extension enables programs to be interpreted using either the polymorphic or monomorphic Blame Calculi.},
booktitle = {Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {303–315},
numpages = {13},
keywords = {type inference, gradual typing},
location = {Mumbai, India},
series = {POPL '15}
}


