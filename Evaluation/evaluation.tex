\chapter{Evaluation}\label{chap:Evaluation}
\textbf{Should I put proposed implementation plans and improvements here or in implementation??}

Evaluation Here.\par 
Evaluate small scope hypothesis for this problem. Note that small inputs don't necessarily correlate with small evaluation traces.

\section{Goals}\label{sec:EvaluationGoals}
i.e. Project Proposal. But make it with more clarity, i.e. `Most Type Errors Admit Witnesses'
Completeness etc. most of Hazel...

\section{Hypotheses}
Various hypotheses for results, mentioned below.

\section{Program Corpus Collection}\label{sec:CorpusCollection}
\textbf{I need a corpus of programs with type errors and a corpus of programs with annotations (which may be well-typed). Currently have neither!! Think I might need help with this...}

Both the above could be transpiled from OCaml, ill-typed ones by just ignoring all types (though this adds some bias to the search procedure, by ignoring partially annotated examples or annotated but ill-typed situations, but it \textit{should} be roughly ok). But sum types etc. may be harder to transpile.
\subsection{Methodology}
\subsection{Alternatives}
OCaml $\to$ Hazel transpiler

\section{Effectiveness Analysis}\label{sec:EffectivenessAnalysis}

\subsection{Search Procedure}
\subsubsection{Witness Coverage}
Describe reasons for failure in next section
\subsubsection{Code Coverage}
Were some branches not taken? `Solvable' via symbolic execution
\subsubsection{Trace Size}
Larger trace sizes are harder to comprehend? Cite...
\subsubsection{Cast Slice Size}
Common complaints on error slices are large slice sizes. cite... 
Does this correlate with trace size?

\subsection{Type Slicing}
\subsubsection{Correctness}
?
\subsubsection{Code Slice Size}
Compare large theory slices with the `simplified' slices.


\section{Performance Analysis}\label{sec:PerformanceAnalysis}
\subsection{Search Procedure}
\subsubsection{Time}
\subsubsection{Space}
Lazy list stuff in particular...

\subsection{Slices}
\subsubsection{Time}
Very slice when used continuously... This might be due to bad design or bugs?
\subsubsection{Space}
Compare with using using `Typ (slices turned off). Compare with old implementation (if possible)

Cast slices should be small as they only use sub-parts of terms and mostly exist at the leaves, or are incremental parts (i.e. to [?]). Compare the slice size of \textit{casts} vs \textit{type} slices.

\section{Critical Analysis}\label{sec:CriticalAnalysis}
\subsection{Slicing}
Which constructs are ignored in simplified slices? Why? Do they have the biggest impact on size?

Discuss the usability aspects of the 4 different type slicing ideas. Discuss 

\subsection{Structure Editing}
Statics are recalculated upon edits and even cursor movement in Hazel. The previous results show that slicing is a \textit{relatively expensive} operation, and not so suitable for such a rapid use case. In this section I discuss ideas for reducing the recalculation during local edits. \textbf{Check out Hazel's incrementalisation efforts too to see if they help} 

The Hazel structure editor allows efficient\footnote{Constant time.} updating of the external syntax tree via the use of a zipper. It would make sense to extend this zipper idea into the abstract syntax tree and it's statics (typing information), allowing allow local changes to propagate to local changes (and type changes) in the AST zipper. Some local changes can propagate type changes \textit{non-locally} (e.g. inserting a new binding) which would require extensive recalculation of the typed AST, but these would be relatively rare (\textbf{provide evidence for this?}). 

This would require an entire rewrite of the Hazel statics.
\subsection{Cast Laziness}
Annotations will create casts, but in many cases these annotations will never actually be used. i.e. on a product where only the 2nd element is ever used, a cast error on the 1st element is still caught. Eager casts catch these errors, lazy casts do NOT.

\subsection{Cast Errors during Evaluation}
Cast errors may appear during evaluation, but subsequently ignored as they may be discarded upon further evaluation. i.e. we get to a safe result, even though a cast error appeared on the way. It is debatable if this should count as an error. Should be easy to implement a version which catches this and do some tests?
  
\subsection{Static-Dynamic Error Correspondence}
How to find dynamic errors for specific chosen static errors. Works well for some types of errors (inconsistency ones). But not for ones like inconsistent branches, show how this could be extended. Indet evaluation still allows these to be witnessed, but they just don't actually go to a cast error.
  
\subsection{Categorising Programs Lacking Type Error Witnesses}
\subsubsection{Non-Termination}
The original procedure would get stuck on programs that loop forever. (To) Fix with iterative deepening
\subsubsection{Repeated Instantiations}
A hole being instantiated to a hole. Does this ever happen??
\subsubsection{Dead Code}
Search proc cannot reach, and failed cast detection would never find one there even if it existed (i.e. statically found).
\subsubsection{Dynamically Safe Code}
Code that is safe to run in all situations, but still exhibits a static type error.

\subsubsection{Needle in a Haystack}
Very specific input required from multiple hole instantiations. Combinatorial explosion makes this very hard to find (solve with coverage directed search, but this requires SMT solvers at least).

\subsection{Non-Local Errors}
Useful when type correct code written but used in the wrong way, i.e. write the wrong map function with @ still has a valid type. Especially prevalent with global inference.
\subsection{Bidirectional Type Error Localisation}
It is generally good. Find some cases where bidirectional type error localisation is wrong.
\subsection{Improving Hole Instantiation}
To improve code coverage. i.e. Strings and Floats are annoying, SMT solvers could be used to help explore branches... Equality solvers in particular would be very useful and quite easy to implement, in particular for strings which are generally used via equality as opposed to lists which are used incrementally via pattern matching.
\subsection{Combinatorial Explosion}
State space gets very large as more holes are instantiated from other holes, i.e. $[] \to [\dyn] \to [\dyn, \dyn] \to [\dyn,\dyn,\dyn]$...
